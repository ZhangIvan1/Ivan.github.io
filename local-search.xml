<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust学习-制作一个文本编辑器: Raw Input And Output</title>
    <link href="/p/156e55dd.html"/>
    <url>/p/156e55dd.html</url>
    
    <content type="html"><![CDATA[<h2 id="使用键代替Byte">使用<code>键</code>代替<code>Byte</code></h2><p>在之前的步骤中，我们直接操作字节。然而，本着“不重复造轮子”的原则，我们可以使用各种库函数已经实现的方法。<code>termion</code>就已经提供了这个方法，它可以将单个字节组合成按键输入，并传递给我们：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, stdout&#125;;<br><span class="hljs-keyword">use</span> termion::raw::IntoRawMode;<br><span class="hljs-keyword">use</span> termion::event::Key;<br><span class="hljs-keyword">use</span> termion::input::TermRead;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">die</span>(e: std::io::Error)&#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">key</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">keys</span>()&#123;<br>        <span class="hljs-keyword">match</span> key&#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(key) =&gt; <span class="hljs-keyword">match</span> key&#123;<br>                Key::<span class="hljs-title function_ invoke__">Char</span>(c) =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> c.<span class="hljs-title function_ invoke__">is_control</span>() &#123;<br>                        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\r&quot;</span>, c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; (&#123;&#125;) \r&quot;</span>, c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>, c);<br>                    &#125;<br>                &#125;<br>                Key::<span class="hljs-title function_ invoke__">Ctrl</span>(<span class="hljs-string">&#x27;q&#x27;</span>) =&gt; <span class="hljs-keyword">break</span>,<br>                _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\r&quot;</span>, key),<br>            &#125;,<br>            <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-title function_ invoke__">die</span>(err),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们已经从处理原始字节转变为处理按键输入。利用<code>termion</code>，无需手动检测<code>Ctrl</code>是否被按下，因为它能自动处理所有按键事件。例如，<code>Key::Char(c)</code>代表单独的字符按键，而<code>Key::Ctrl(c)</code>和<code>Key::Alt(c)</code>分别代表与<code>Ctrl</code>或<code>Alt</code>键同时按下的字符。我们的焦点主要在字符输入上，尤其是像<code>Ctrl-Q</code>这样的组合键。</p><p>在使用<code>match</code>进行模式匹配时，会对按键进行区分处理：<code>Key::Char(c)</code>可以匹配任何字符，<code>Key::Ctrl('q')</code>则专门匹配<code>Ctrl-Q</code>组合。此前，我们将字节转换为字符以输出，而现在，<code>termion</code>提供了直接的字符输出，通过将字符转换为其对应的字节值来输出。</p><p>我们在<code>match</code>表达式中添加了一个默认分支<code>_</code>，用于捕获所有其他未特别处理的情况。<code>match</code>必须包含所有可能性，因此<code>_</code>作为一个通配符，确保了所有未预见的输入都得到了处理。若有输入既不是普通字符也不是特定组合键，就将其原样输出。</p><p>除此之外，为了简化代码，我们导入了<code>TermRead</code>特性，这样就可以使用<code>keys</code>方法来处理<code>stdin</code>输入，这比之前直接处理读取操作要简洁得多。</p><h2 id="将代码划分到多个源文件">将代码划分到多个源文件</h2><p>在<code>Rust</code>和许多其他编程语言中，<code>main</code>函数更多的是作为应用程序的启动入口，而不包含其他复杂逻辑。这是为了让代码更容易找到和维护。目前我们手头的代码层次较低，要理解整个代码，本质上它只是简单地将按下的键回显给用户，并在按下 <code>Ctrl-Q</code> 时退出。让我们通过创建多个文档来改进这段代码。</p><figure class="highlight rust"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Editor</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>在<code>Rust</code>中，<code>struct</code>是变量和函数的集合，它们组合在一起构成了一个有意义的实体，在我们的例子中就是<code>editor</code>。关键字<code>pub</code>表明这个结构体可以从<code>editor.rs</code>文件外部访问。我们想要在<code>main</code>函数中使用它，因此我们使用了<code>pub</code>。这正展示了将代码分离的另一个好处：<strong>我们可以确保某些函数只在内部调用，同时将其他函数暴露给系统的其他部分。</strong></p><p>现在，我们的编辑器需要一些功能。让我们为它提供一个<code>run()</code>函数：</p><figure class="highlight rust"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, stdout&#125;;<br><span class="hljs-keyword">use</span> termion::event::Key;<br><span class="hljs-keyword">use</span> termion::input::TermRead;<br><span class="hljs-keyword">use</span> termion::raw::IntoRawMode;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Editor</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">key</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">keys</span>()&#123;<br>            <span class="hljs-keyword">match</span> key&#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(key) =&gt; <span class="hljs-keyword">match</span> key&#123;<br>                    Key::<span class="hljs-title function_ invoke__">Char</span>(c) =&gt; &#123;<br>                        <span class="hljs-keyword">if</span> c.<span class="hljs-title function_ invoke__">is_control</span>() &#123;<br>                            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\r&quot;</span>, c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; (&#123;&#125;) \r&quot;</span>, c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>, c);<br>                        &#125;<br>                    &#125;<br>                    Key::<span class="hljs-title function_ invoke__">Ctrl</span>(<span class="hljs-string">&#x27;q&#x27;</span>) =&gt; <span class="hljs-keyword">break</span>,<br>                    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\r&quot;</span>, key),<br>                &#125;,<br>                <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-title function_ invoke__">die</span>(err),<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">die</span>(e: std::io::Error)&#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>run</code>函数接受一个名为 <code>&amp;self</code> 的参数，它将包含对被调用结构体的引用（<code>&amp;</code> 表明我们在处理一个引用）。这相当于在 <code>impl</code> 代码块外部有一个接受 <code>&amp;Editor</code> 作为第一个参数的函数。</p><p>让我们通过重构我们的 <code>main.rs</code> ：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> editor;<br><br><span class="hljs-keyword">use</span> editor::Editor;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">editor</span> = Editor &#123;&#125;;<br>    editor.<span class="hljs-title function_ invoke__">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>main</code>中，我们创建了一个 <code>Editor</code> 的新实例，并在其上调用 <code>run()</code> 方法。现在，让我们改进 <code>main</code> 中剩下的几行代码。结构体允许我们将变量组合在一起，但目前我们的结构体是空的——它不包含任何变量。一旦我们开始往结构体中添加内容，我们就需要在创建新的 <code>Editor</code> 实例时立即设置所有字段。这意味着每当在 <code>Editor</code> 中添加新条目时，我们都必须回到 <code>main</code> 函数中，并修改 <code>let editor = editor::Editor&#123;&#125;;</code> 这行代码来设置新的字段值。这样做并不理想，所以让我们重构一下这部分代码。</p><figure class="highlight rust"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*codes*/</span><br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-comment">/*codes*/</span><br>    <br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">default</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Editor&#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*codes*/</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> editor;<br><br><span class="hljs-keyword">use</span> editor::Editor;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">editor</span> = Editor::<span class="hljs-title function_ invoke__">default</span>();<br>    editor.<span class="hljs-title function_ invoke__">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在创建了一个名为 <code>default</code> 的新函数，用于构建一个 <code>Editor</code> 实例。值得注意的是，<code>default</code> 函数的最后一行没有包含 <code>return</code> 关键字，也没有以分号 <code>;</code> 结尾。<strong><code>Rust</code> 会将函数中最后一行的结果作为其输出，并且通过省略分号。</strong></p><p>与 <code>run</code> 不同，<code>default</code> 函数不是在已有的 <code>Editor</code> 实例上调用的，这一点从函数签名中缺少 <code>&amp;self</code> 参数可以看出。<code>default</code> 是一个静态方法，通过使用 <code>::</code> 调用。</p><h2 id="分离读取和处理">分离读取和处理</h2><p>让我们创建一个用于读取按键的函数，以及另一个函数用于将按键映射到编辑器操作：</p><figure class="highlight rust"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*codes*/</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Err</span>(error) = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">process_keypress</span>() &#123;<br>                <span class="hljs-title function_ invoke__">die</span>(error)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*codes*/</span><br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_keypress</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), std::io::Error&gt;&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pressed_key</span> = <span class="hljs-title function_ invoke__">read_key</span>()?;<br>        <span class="hljs-keyword">match</span> pressed_key &#123;<br>            Key::<span class="hljs-title function_ invoke__">Ctrl</span>(<span class="hljs-string">&#x27;q&#x27;</span>) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Program end&quot;</span>),<br>            _ =&gt; ()<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_key</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Key, std::io::Error&gt; &#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(key) = io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">keys</span>().<span class="hljs-title function_ invoke__">next</span>() &#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*codes*/</span><br></code></pre></td></tr></table></figure><p>我们现在在<code>run</code>函数中添加了一个循环。循环会一直重复执行，直到被明确地中断。在这个循环内，我们使用了<code>Rust</code>的另一个特性：<code>if let</code>。这是<code>match</code>的简写形式，用于只处理一个情况而忽略所有其他可能的情况。你可以查看<code>process_keypress()</code>函数的代码，了解一个可以完全用 <code>if let</code> 替代的 <code>match</code> 情况。</p><p>在<code>run</code>中，执行<code>self.process_keypress()</code>并检查结果是否匹配<code>Err</code>。如果是，就将错误解包并传递给<code>die</code>函数，如果不是，则不做任何事情。</p><p>我们可以通过查看<code>process_keypress</code>函数的声明来更清晰地了解这一点：</p><figure class="highlight rust"><figcaption><span>process_keypress()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_keypress</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), std::io::Error&gt;<br></code></pre></td></tr></table></figure><p><code>-&gt;</code>后面的部分表明：这个函数返回一个<code>Result</code>类型。<code>&lt;&gt;</code>里的内容告诉我们<code>Ok</code>和<code>Err</code>分别包含什么内容：<code>Ok</code>会包裹一个<code>()</code>，意味着<strong>无内容</strong>，而<code>Err</code>会包裹一个<code>std::io::Error</code>。<code>process_keypress()</code>函数等待按键输入，然后处理它。随后，它会将各种<code>Ctrl</code>组合键和其他特殊键映射到不同的编辑器功能，将任何字母数字和其他可打印键的字符插入到正在编辑的文本中。这就是为什么在这里使用<code>match</code>而不是<code>if let</code>。</p><p>这个函数的最后一行可能有点难以理解。我们不希望函数返回任何内容，那么为什么要用<code>ok(())</code>呢？这是因为：调用<code>read_key</code>时可能会出现错误，我们希望将这个错误传递给调用函数。由于<code>Rust</code>没有<code>try..catch</code>，我们需要返回一个表示<strong>一切正常</strong>的东西，即使我们实际上没有返回任何值。这正是<code>ok(())</code>所做的：它表示：<strong>一切正常，没有返回任何内容</strong>。</p><p>但如果出现了错误怎么办呢？从<code>read_key</code>的声明中我们可以看出，错误可能会传递给我们。如果真的如此，就没有继续执行的必要了，我们希望错误也被返回。但如果没有发生错误，我们希望继续执行，并使用未包装的值。<code>let pressed_key = read_key()?</code>中的<code>?</code>的就是为此服务的：<strong>如果有错误，就返回它，如果没有，就解包值并继续</strong>。</p><p><code>read_key</code>函数也包含一个循环，在按下有效键后循环会结束。<code>io::stdin().lock().keys().next()</code>返回的值与上文讨论的<code>Result</code>很相似——这是一个叫做<code>Option</code>的类型。目前你只需要知道<code>Option</code>可以是<code>None</code>——在这种情况下意味着没有按键被按下，循环会继续；或者它可以包裹一个<code>Some</code>值，在这种情况下我们返回从<code>read_key</code>中解包的值。</p><p>更复杂的是<code>io::stdin().lock().keys().next()</code>的实际返回值是一个包裹在<code>Result</code>里的<code>Key</code>，而这个<code>Result</code>又被包裹在一个<code>Option</code>里。我们在<code>read_key()</code>中解包<code>Option</code>，然后在<code>process_keypress()</code>中处理<code>Result</code>。</p><p>这就是错误如何传递到<code>run</code>中并最终由<code>die</code>处理的方式。说到<code>die</code>，我们的代码中出现了一个新的问题：由于我们还不知道如何从程序内部退出，所以当用户按下<code>Ctrl-Q</code>时，我们现在会调用<code>painc</code>。</p><p>我们可以调用一个适当的方法来结束程序（如<code>std::process::exit</code>），但正如我们不希望程序在代码深处随机崩溃一样，我们也不希望它在代码的深层部分退出。我们通过向<code>Editor</code>结构体添加一个元素来解决这个问题：<strong>一个布尔值</strong>，用于指示用户是否想要退出：</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-pub struct Editor &#123;&#125;</span><br><span class="hljs-addition">+pub struct Editor &#123;</span><br><span class="hljs-addition">+    should_quit: bool,</span><br><span class="hljs-addition">+&#125;</span><br> <br> impl Editor &#123;<br>     pub fn run(&amp;self) &#123;<br>         let _stdout = stdout().into_raw_mode().unwrap();<br>     <br>         loop &#123;<br>             if let Err(error) = self.process_keypress() &#123;<br>                 die(error)<br>             &#125;<br>         &#125;<br>     &#125;<br> <br>     pub fn default() -&gt; Self &#123;<br><span class="hljs-deletion">-        Self &#123;&#125;</span><br><span class="hljs-addition">+        Self &#123; should_quit: false &#125;</span><br>     &#125;<br></code></pre></td></tr></table></figure><p>我们需要在<code>default</code>函数中立即初始化<code>should_quit</code>，否则我们的代码无法编译。现在就设置这个布尔值，并在它为 <code>true</code> 时退出程序。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs diff"> impl Editor &#123;<br><span class="hljs-deletion">-    pub fn run(&amp;self) &#123;</span><br><span class="hljs-addition">+    pub fn run(&amp;mut self) &#123;</span><br>         let _stdout = stdout().into_raw_mode().unwrap();<br>     <br>         loop &#123;<br>             if let Err(error) = self.process_keypress() &#123;<br>                 die(error)<br>             &#125;<br><span class="hljs-addition">+            if self.should_quit &#123;</span><br><span class="hljs-addition">+                break;</span><br><span class="hljs-addition">+            &#125;</span><br>         &#125;<br>     &#125;<br> <br>     pub fn default() -&gt; Self &#123;<br>         Self &#123; should_quit: false &#125;<br>     &#125;<br> <br><span class="hljs-deletion">-    fn process_keypress(&amp;self) -&gt; Result&lt;(), std::io::Error&gt;&#123;</span><br><span class="hljs-addition">+    fn process_keypress(&amp;mut self) -&gt; Result&lt;(), std::io::Error&gt;&#123;</span><br>         let pressed_key = read_key()?;<br>         match pressed_key &#123;<br><span class="hljs-deletion">-            Key::Ctrl(&#x27;q&#x27;) =&gt; panic!(&quot;Program end&quot;),</span><br><span class="hljs-addition">+            Key::Ctrl(&#x27;q&#x27;) =&gt; self.should_quit = true,</span><br>             _ =&gt; ()<br>         &#125;<br>         Ok(())<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -5,6 +5,5 @@</span> mod editor;<br> use editor::Editor;<br> <br> fn main() &#123;<br><span class="hljs-deletion">-    let editor = Editor::default();</span><br><span class="hljs-deletion">-    editor.run();</span><br><span class="hljs-addition">+    Editor::default().run()</span><br> &#125;<br></code></pre></td></tr></table></figure><p>我们现在让<code>should_quit</code>为<code>true</code>时用<code>break</code>来终止循环，并在<code>run</code>函数中检查这一点。这使得程序退出的逻辑比之前清晰得多。</p><p>此外，我们还做了一些调整。在<code>process_keypress()</code>函数中，我们对<code>self</code>进行了修改，因此需要将参数从<code>&amp;self</code>改为<code>&amp;mut self</code>，以便能够修改引用。<code>Rust</code>对可变引用有严格的规则。</p><p>同样地，由于<code>run</code>函数内部需要调用<code>process_keypress()</code>，我们也调整了它的函数声明。</p><p>最后，在<code>main</code>函数中，<code>let editor = ...</code>表示<code>editor</code>是不可变的，我们不能在其上执行可能会修改它的<code>run</code>。为此我们将其改为<code>let mut editor</code>。现在我们不再需要<code>editor</code>变量，直接在<code>default()</code>的返回值上调用<code>run()</code>。</p><h2 id="清空屏幕">清空屏幕</h2><p>在之前，用户每次按键时，都会打印在屏幕上。现在让我们清空屏幕。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,4 +1,4 @@</span><br><span class="hljs-deletion">-use std::io::&#123;self, stdout&#125;;</span><br><span class="hljs-addition">+use std::io::&#123;self, stdout, Write&#125;;</span><br> use termion::event::Key;<br> use termion::input::TermRead;<br> use termion::raw::IntoRawMode;<br><span class="hljs-meta">@@ -10,14 +10,17 @@</span> pub struct Editor &#123;<br> impl Editor &#123;<br>     pub fn run(&amp;mut self) &#123;<br>         let _stdout = stdout().into_raw_mode().unwrap();<br>    <br>         loop &#123;<br><span class="hljs-deletion">-            if let Err(error) = self.process_keypress() &#123;</span><br>             if let Err(error) = self.refresh_screen() &#123;<br>                 die(error)<br><span class="hljs-addition">+            &#125;</span><br>             if self.should_quit &#123;<br>                 break;<br>             &#125;<br><span class="hljs-addition">+            if let Err(error) = self.process_keypress() &#123;</span><br><span class="hljs-addition">+                die(error)</span><br><span class="hljs-addition">+            &#125;</span><br>         &#125;<br>     &#125;<br> <br><span class="hljs-meta">@@ -25,11 +28,16 @@</span> impl Editor &#123;<br>         Self &#123; should_quit: false &#125;<br>     &#125;<br> <br><span class="hljs-addition">+    fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;</span><br><span class="hljs-addition">+        print!(&quot;\x1b[2J&quot;);</span><br><span class="hljs-addition">+        io::stdout().flush()</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+</span><br>     fn process_keypress(&amp;mut self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br>         let pressed_key = read_key()?;<br>         match pressed_key &#123;<br>             Key::Ctrl(&#x27;q&#x27;) =&gt; self.should_quit = true,<br>             _ =&gt; (),<br>         &#125;<br>         Ok(())<br>     &#125;<br></code></pre></td></tr></table></figure><p>我们新增了一个名为<code>refresh_screen</code>的函数，在退出程序前调用。我们将<code>process_keypress()</code>移至较低的位置，这意味着**即使用户退出程序，我们仍会在最终退出前刷新一次屏幕。**这样做是为了后续能打印退出消息。</p><p>为了清屏，我们使用<code>print</code>函数向终端写入4个字节。第一个字节是<code>\x1b</code>，即转义字符，十进制下是27。其余三个字节是<code>[2J</code>。</p><p>我们正在向终端写入一个转义序列。转义序列总是以转义字符（如<code>Esc</code>键产生的27）开始，后跟一个<code>[</code>字符。转义序列指示终端执行各种文本格式化任务，如改变文本颜色、移动光标或清除屏幕的部分内容。</p><p>我们使用<code>J</code>命令<code>(Erase In Display)</code>来清除屏幕。转义序列命令通常会带参数，参数位于命令之前。在这里参数是<code>2</code>，表示清除整个屏幕。<code>\x1b[1J</code>会清除光标处到屏幕顶部的内容，而<code>\x1b[0J</code>会清除光标处到屏幕末尾的内容。<code>J</code>命令默认的参数就是<code>0</code>，所以只写<code>\x1b[J</code>也能从光标处清屏到末尾。</p><p>向终端写入内容后，我们会调用<code>flush()</code>，它会强制<code>stdout</code>输出它所缓存的所有内容（有时它可能会缓存某些值而不是直接打印出来）。我们也返回了<code>flush()</code>的结果，与前面类似，要么是<code>Ok</code>表示没有值（即一切正常），要么是<code>Err</code>包装了一个错误（即刷新失败）。这一点很重要：如果我们在<code>flush()</code>之后添加了;`，我们就不会返回它的结果。</p><p>使用<code>termion</code>库让我们无需直接向终端写入转义序列，因此我们可以按照如下方式修改代码：</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -29,7 +29,7 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br><span class="hljs-deletion">-        print!(&quot;\x1b[2J&quot;);</span><br><span class="hljs-addition">+        print!(&quot;&#123;&#125;&quot;,termion::clear::All);</span><br>         io::stdout().flush()<br>     &#125;<br></code></pre></td></tr></table></figure><p>现在，由于我们现在每次运行程序都会清屏，我们可能会错过编译器提供的有价值的提示。可以通过单独运行<code>cargo build</code>来查看这些警告。但请记住，<strong>如果你的代码没有变化，<code>Rust</code>不会重新编译你的代码</strong>，所以在执行<code>cargo run</code>之后立即运行<code>cargo build</code>并不会显示相同的警告。你可以先运行<code>cargo clean</code>然后再运行<code>cargo build</code>来重新编译整个项目，并查看所有的警告。</p><h2 id="光标重定位">光标重定位</h2><p>在前面的代码中，虽然执行了清屏的操作，但是光标依然会停留在以前的位置。我们需要将光标重新定位到左上角，以便准备从上到下绘制编辑器界面。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -29,7 +29,7 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br><span class="hljs-deletion">-        print!(&quot;&#123;&#125;&quot;,termion::clear::All);</span><br><span class="hljs-addition">+        print!(&quot;&#123;&#125;&#123;&#125;&quot;, termion::clear::All, termion::cursor::Goto(1, 1));</span><br>         io::stdout().flush()<br>     &#125;<br></code></pre></td></tr></table></figure><p><code>termion</code>库中的转义序列<code>termion::cursor::Goto</code>使用<a href="https://vt100.net/docs/vt100-ug/chapter3.html#CUP"><code>H</code>命令</a>来定位光标，它实际上需要两个参数：行号和列号，来确定光标的新位置。因此，如果你的终端大小是<code>80x24</code>，并且你想要将光标置于屏幕中心，你可以使用<code>\x1b[12;40H</code>命令（多个参数之间用分号<code>;</code>分隔）。由于行和列的编号是从<code>1</code>开始的，而不是<code>0</code>，所以<code>termion</code>方法也是基于<code>1</code>的索引。</p><h2 id="退出时清屏">退出时清屏</h2><p>当我们的程序崩溃时，就清屏并重新定位光标。如果在渲染屏幕的过程中发生错误，我们不希望屏幕上留下一堆乱码，也不希望错误信息就在光标当前的位置被打印出来。此外，如果用户决定退出，我们也会借此机会打印一条告别信息。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -30,6 +30,9 @@</span> impl Editor &#123;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br>         print!(&quot;&#123;&#125;&#123;&#125;&quot;, termion::clear::All, termion::cursor::Goto(1, 1));<br><span class="hljs-addition">+        if self.should_quit &#123;</span><br><span class="hljs-addition">+            println!(&quot;Goodbye.\r&quot;);</span><br><span class="hljs-addition">+        &#125;</span><br>         io::stdout().flush()<br>     &#125;<br> <br><span class="hljs-meta">@@ -52,5 +55,6 @@</span> fn read_key() -&gt; Result&lt;Key, std::io::Error&gt; &#123;<br> &#125;<br> <br> fn die(e: std::io::Error) &#123;<br><span class="hljs-addition">+    print!(&quot;&#123;&#125;&quot;, termion::clear::All);</span><br>     panic!(&quot;&#123;&#125;&quot;, e);<br> &#125;<br></code></pre></td></tr></table></figure><h2 id=""><code>~</code></h2><p>是时候开始绘制界面了。让我们在屏幕的左侧绘制一列波浪号<code>~</code>，就像<code>vim</code>编辑器那样。在我们的文本编辑器中，我们将在被编辑文件内容结束后的每一行的开头绘制一个波浪号。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -32,6 +32,9 @@</span> impl Editor &#123;<br>         print!(&quot;&#123;&#125;&#123;&#125;&quot;, termion::clear::All, termion::cursor::Goto(1, 1));<br>         if self.should_quit &#123;<br>             println!(&quot;Goodbye.\r&quot;);<br><span class="hljs-addition">+        &#125; else &#123;</span><br><span class="hljs-addition">+            self.draw_rows();</span><br><span class="hljs-addition">+            print!(&quot;&#123;&#125;&quot;, termion::cursor::Goto(1, 1));</span><br>         &#125;<br>         io::stdout().flush()<br>     &#125;<br><span class="hljs-meta">@@ -44,6 +47,12 @@</span> impl Editor &#123;<br>         &#125;<br>         Ok(())<br>     &#125;<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    fn draw_rows(&amp;self) &#123;</span><br><span class="hljs-addition">+        for _ in 1..24 &#123;</span><br><span class="hljs-addition">+            println!(&quot;~\r&quot;);</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br> <br> fn read_key() -&gt; Result&lt;Key, std::io::Error&gt; &#123;<br></code></pre></td></tr></table></figure><p><code>draw_rows()</code>函数负责绘制正在编辑的文本缓冲区的每一行。现在，它在每一行都绘制一个波浪符号，这表示**该行不是文件的一部分，也不会包含任何文本。**我们还不知道终端的大小，因此也不知道要绘制多少行。目前我们只绘制<code>24</code>行。在<code>for _ in</code>循环中，<code>_</code>表示我们不关心任何值，只是想重复执行某个操作多次。绘制完毕后，我们将光标重新定位到左上角。</p><h2 id="窗口大小">窗口大小</h2><p>我们接下来的目标是获取终端的尺寸，这样我们就知道在 <code>draw_rows()</code> 中需要绘制多少行。 <code>termion</code> 为我们提供了一个获取屏幕尺寸的方法，我们将使用这个方法在代表终端的新数据结构中。我们会将其放在一个名为 <code>terminal.rs</code> 的新文件中。</p><figure class="highlight diff"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,9 +1,11 @@</span><br> #![allow(non_snake_case)]<br> <br> mod editor;<br><span class="hljs-addition">+mod terminal;</span><br> <br> use editor::Editor;<br><span class="hljs-addition">+pub use terminal::Terminal;</span><br> <br> fn main() &#123;<br>     Editor::default().run()<br><span class="hljs-deletion">-&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,3 +1,4 @@</span><br><span class="hljs-addition">+use crate::Terminal;</span><br> use std::io::&#123;self, stdout, Write&#125;;<br> use termion::event::Key;<br> use termion::input::TermRead;<br><span class="hljs-meta">@@ -5,6 +6,7 @@</span> use termion::raw::IntoRawMode;<br> <br> pub struct Editor &#123;<br>     should_quit: bool,<br><span class="hljs-addition">+    terminal: Terminal,</span><br> &#125;<br> <br> impl Editor &#123;<br><span class="hljs-meta">@@ -25,7 +27,10 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     pub fn default() -&gt; Self &#123;<br><span class="hljs-deletion">-        Self &#123; should_quit: false &#125;</span><br><span class="hljs-addition">+        Self &#123;</span><br><span class="hljs-addition">+            should_quit: false,</span><br><span class="hljs-addition">+            terminal: Terminal::default().expect(&quot;Failed to initialize terminal&quot;),</span><br><span class="hljs-addition">+        &#125;</span><br>     &#125;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br><span class="hljs-meta">@@ -49,7 +54,7 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn draw_rows(&amp;self) &#123;<br><span class="hljs-deletion">-        for _ in 1..24 &#123;</span><br><span class="hljs-addition">+        for _ in 0..self.terminal.size().height &#123;</span><br>             println!(&quot;~\r&quot;);<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/terminal.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -0,0 +1,24 @@</span><br><span class="hljs-addition">+pub struct Size &#123;</span><br><span class="hljs-addition">+    pub width: u16,</span><br><span class="hljs-addition">+    pub height: u16,</span><br><span class="hljs-addition">+&#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+pub struct Terminal &#123;</span><br><span class="hljs-addition">+    size: Size,</span><br><span class="hljs-addition">+&#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+impl Terminal &#123;</span><br><span class="hljs-addition">+    pub fn default() -&gt; Result&lt;Self, std::io::Error&gt; &#123;</span><br><span class="hljs-addition">+        let size = termion::terminal_size()?;</span><br><span class="hljs-addition">+        Ok(Self &#123;</span><br><span class="hljs-addition">+            size: Size &#123;</span><br><span class="hljs-addition">+                width: size.0,</span><br><span class="hljs-addition">+                height: size.1,</span><br><span class="hljs-addition">+            &#125;,</span><br><span class="hljs-addition">+        &#125;)</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn size(&amp;self) -&gt; &amp;Size &#123;</span><br><span class="hljs-addition">+        &amp;self.size</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+&#125;</span><br></code></pre></td></tr></table></figure><p>在<code>terminal.rs</code>中，我们定义了 <code>Terminal</code> 和一个辅助结构体 <code>Size</code>。在 <code>default</code> 中，我们获取了 <code>termion</code> 的 <code>terminal_size</code>，并将其转换为 <code>Size</code>，然后返回 <code>Terminal</code> 的新实例。为了处理潜在的错误，我们将其包装在 <code>Ok</code> 中。我们也不想让外部调用者修改终端尺寸。因此，我们没有用 <code>pub</code> 标记 <code>size</code> 为公开的。相反，我们添加了一个名为 <code>size</code> 的方法，它返回对内部 <code>size</code> 的只读引用。<code>Size.width</code> 和 <code>height</code> 都是 <code>u16s</code>，是一个无符号的16位整数，大约在65,000左右结束。这对于终端来说很够用了。</p><p>现在对于新的结构体，让我们研究一下它是如何从编辑器中被引用的。首先，我们在 <code>main.rs</code> 中像编辑器一样引入我们的新结构体，并在 <code>Terminal</code> 结构体前添加了 <code>pub</code> 使其公开。这样做有什么作用呢？-- 在 <code>editor.rs</code> 中，我们现在可以使用 <code>use crate::Terminal</code> 来导入终端。如果没有在 <code>main.rs</code> 中使用 <code>pub use</code> 语句，我们就不能这样做，相反我们需要使用 <code>use crate::terminal::Terminal</code>。实质上，我们在顶层导出了 <code>Terminal</code> 结构体，并通过 <code>crate::Terminal</code> 使其可达。</p><p>在我们的编辑器结构体中，我们在初始化 <code>default()</code> 时添加了对我们终端的引用。注意 <code>Terminal::default</code> 返回一个 <code>Terminal</code> 实例或一个错误。我们用 <code>expect</code> 解包 <code>Terminal</code>，如果我们有一个值，我们返回它。如果我们没有一个值，我们就会带着传递给 <code>expect</code> 的文本引发<code>painc</code>。在这里我们不需要 <code>die</code>，因为 <code>die</code> 主要在我们重复绘制屏幕时才有用。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/156e55dd.html">https://zone.ivan-zhang.com.cn/p/156e55dd.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>TextEditor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust学习-制作一个文本编辑器: Reading User Input</title>
    <link href="/p/8e0787d5.html"/>
    <url>/p/8e0787d5.html</url>
    
    <content type="html"><![CDATA[<h2 id="读取用户的输入">读取用户的输入</h2><p>现在来尝试读取用户的输入操作，<code>main.rs</code>如下：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b.<span class="hljs-title function_ invoke__">unwrap</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>use</code>类似于<code>import</code>或<code>include</code>，用来引入我们要使用的库。在这里我们使用<code>io</code>用来进行输入输出操作<code>use std::io::&#123;self, Read&#125;;</code>，这一步相当于：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br></code></pre></td></tr></table></figure><p><code>main</code>函数中主要包含一个循环，其中<code>io::stdin().bytes()</code>将返回一个<strong>迭代器</strong>，在每一轮循环前赋值给<code>b</code>后进入循环，直到没有可以读的内容了。我们可以通过<code>Ctrl+D</code>来发出<code>eof</code>，或者直接<code>Ctrl+C</code>来终止程序。</p><p>在实际运行的时候，这个程序会将用户输入的字符串打印出来。然而，在默认情况下，仅当用户按下<code>Enter</code>时输入才会发送给程序，这也允许用户通过·来编辑修复内容（<code>canonical mode / cooked mode</code>），但是对于一个文本编辑器来说，我们希望在按下键盘时程序能立刻响应（<code>raw mode</code>）。</p><h2 id="输入Q来退出">输入<code>Q</code>来退出</h2><p>当程序收到用户按下<code>Q</code>时，退出程序：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b.<span class="hljs-title function_ invoke__">unwrap</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;q&#x27;</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，在<code>Rust</code>中，字符需要用单引号<code>''</code>包裹，字符串是双引号<code>&quot;&quot;</code>，这和<code>C++</code>是类似的。</p><p>现在当我们在程序中输入<code>q</code>，循环将停止，程序就会退出了，而在<code>q</code>后面的字符不会被打印，并在程序退出时一起被销毁。</p><h2 id="Raw-Mode">Raw Mode</h2><p>为了切换到<code>Raw Mode</code>，我们需要使用<code>termion</code>，可以在<code>Cargo.toml</code>中引入：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">termion</span> = <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><p>我们再次运行<code>cargo build</code>或<code>run</code>，就会下载并编译<code>termion</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">Updating</span> crates.io index<br><span class="hljs-attribute">Downloaded</span> libc v0.<span class="hljs-number">2</span>.<span class="hljs-number">150</span><br><span class="hljs-attribute">Downloaded</span> numtoa v0.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Downloaded</span> termion v1.<span class="hljs-number">5</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">Downloaded</span> <span class="hljs-number">3</span> crates (<span class="hljs-number">751</span>.<span class="hljs-number">0</span> KB) in <span class="hljs-number">6</span>.<span class="hljs-number">06</span>s<br> <span class="hljs-attribute">Compiling</span> libc v0.<span class="hljs-number">2</span>.<span class="hljs-number">150</span><br> <span class="hljs-attribute">Compiling</span> numtoa v0.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br> <span class="hljs-attribute">Compiling</span> termion v1.<span class="hljs-number">5</span>.<span class="hljs-number">6</span><br> <span class="hljs-attribute">Compiling</span> iTEditor v0.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> (/root/iTEditor)<br>  <span class="hljs-attribute">Finished</span> dev<span class="hljs-meta"> [unoptimized + debuginfo] target(s) in 11.53s</span><br></code></pre></td></tr></table></figure><p>现在让我们把<code>main.rs</code>中的代码改写成支持<code>raw mode</code>的：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, stdout, Read&#125;;<br><span class="hljs-keyword">use</span> termion::raw::IntoRawMode;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b.<span class="hljs-title function_ invoke__">unwrap</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;q&#x27;</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用<code>termion</code>提供<code>stdout()</code>并调用<code>into_raw_mode()</code>函数。为什么要在<code>stdout</code>而不是<code>stdin</code>呢？因为终端的状态是由写入者控制而不是读取者。<code>writer</code>用于在屏幕上绘图或移动光标，同时也用于修改模式。</p><p>除此之外，我们还新建了<code>_stdout</code>变量，用于储存<code>into_raw_mode()</code>的返回，但是从未在之后的程序中使用过它。这涉及到Rust中<strong>所有权</strong>的概念，简单来说，终端可以拥有一些属性，不属于自己的东西将会被移除，而<code>into_raw_mode()</code>修改了终端并返回了一个值，我们需要将它储存起来，通过绑定到<code>_stdout</code>变量，一旦删除<code>_stdout</code>，终端就又会变为<code>canonical mode</code>。<code>_stdout</code>的变量名中添加了前缀<code>_</code>，这会告诉编译器我们希望保留这个变量即使没有被使用过，否则在编译时回返回一个<code>warning</code>。</p><p>运行一下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">   Compiling iTEditor v0.<span class="hljs-number">1.0</span> (<span class="hljs-regexp">/root/i</span>TEditor)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.13</span>s<br>     Running `target<span class="hljs-regexp">/debug/i</span>TEditor`<br>d<br> s<br>  j<br>   f<br>    h<br>     s<br>      r<br>       i<br>        <span class="hljs-number">1</span><br>         q<br>          <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h2 id="监视按键">监视按键</h2><p>为了更好的探索<code>Raw Mode</code>的工作，我们让程序输出读到的所有<code>byte</code>：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = b.<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br><span class="hljs-keyword">if</span> c.<span class="hljs-title function_ invoke__">is_control</span>()&#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; \r&quot;</span>, b);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; (&#123;&#125;)\r&quot;</span>, b, c);<br>&#125;<br><span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;q&#x27;</span> &#123;<br><span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中对变量<code>b</code>进行了二次声明，这是叫做<strong>变量遮蔽</strong>的特性：在新变量的作用域中，原先的变量会被屏蔽，这样就不必费心思想新的变量名了。函数<code>is_control()</code>可以用来判断是否是控制字符。控制字符是不可被打印出来的，我们可以在<code>ASCII</code>表中找到他们。</p><center>  <img src="https://cdn.ttgtmedia.com/rms/onlineimages/non_printing_ascii_control_codes-f.png" alt="ASCII" style="zoom:50%;" />  <br>  <font color="DimGray" size="3">Non-printing ASCII control codes.</font></center><p>通过测试我们可以发现，<code>Ctrl+A...Z</code>对应的就是<code>ASCII</code>表中1-26的控制符。</p><h2 id="按Ctrl-Q退出">按<code>Ctrl+Q</code>退出</h2><p>现在我们可以将<code>Ctrl+Q</code>映射到退出操作：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_ctrl_byte</span>(c: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;<br>    byte &amp; <span class="hljs-number">0b0001_1111</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">/*codes*/</span><br>        <span class="hljs-keyword">if</span> b == <span class="hljs-title function_ invoke__">to_ctrl_byte</span>(<span class="hljs-string">&#x27;q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数<code>to_ctrl_byte()</code>将返回字符和<code>00011111</code>相与的二进制结果。</p><h2 id="异常处理">异常处理</h2><p>现在是时候该旅一下如何处理错误了。我们给程序增加一个<code>die()</code>函数打印错误并退出：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">die</span>(e: std::io::Error)&#123;<br>    <span class="hljs-built_in">panic!</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>panic!</code>会导致程序关闭并输出错误信息。和其他语言不一样，<code>Rust</code>没有类似于<code>try...catch</code>的结构来捕获可能发生的错误，取而代之的是，<code>Rust</code>采用一种将错误作为函数返回值的方式进行传递，这样我们就可以在程序的顶层统一处理这些错误。</p><p>在<code>Rust</code>中，当函数可能发生错误时，它会返回一个名为<code>Result</code>的类型。<code>Result</code>是一个包装器，内含期望的结果或一个错误。在这种情况下，每一个值<code>b</code>本质上都是一个<code>Result</code>，它要么包含一个表示已读取字节的<code>Ok</code>，要么包含一个<code>Err</code>，后者包装了一个错误对象，表明在读取字节时出现了问题。为了得到我们需要的值，我们可以调用<code>unwrap</code>方法：如果我们得到的是<code>Ok</code>，就返回它包含的值；如果是<code>Err</code>，则触发<code>panic</code>。</p><p>我们希望在错误发生时自行控制程序崩溃，而不是让Rust直接触发<code>panic</code>，因为后续我们想在程序崩溃前清除屏幕，避免给用户留下未完成绘制的输入信息。目前，我们只需检查错误然后调用<code>die</code>函数，这个函数会替我们执行<code>panic</code>。</p><p>我们通过枚举（<code>match</code>）来实现这个流程，<code>match</code>可以当成一个增强版的<code>if-then-else</code>。由它处理变量<code>b</code>，这个变量要么包含我们想要的值，这个值被<code>Ok</code>包装，要么包含一个错误，这个错误被<code>Err</code>包装：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>    <span class="hljs-keyword">match</span> b&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(b) =&gt; &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br>            <span class="hljs-keyword">if</span> c.<span class="hljs-title function_ invoke__">is_control</span>() &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; \r&quot;</span>, b);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; (&#123;&#125;)\r&quot;</span>, b, c);<br>            &#125;<br>            <span class="hljs-keyword">if</span> b == <span class="hljs-title function_ invoke__">to_ctrl_byte</span>(<span class="hljs-string">&#x27;q&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-title function_ invoke__">die</span>(err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/8e0787d5.html">https://zone.ivan-zhang.com.cn/p/8e0787d5.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>TextEditor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust学习-制作一个文本编辑器: Setup</title>
    <link href="/p/e62fb29b.html"/>
    <url>/p/e62fb29b.html</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>参考 <a href="https://www.flenker.blog/hecto/">https://www.flenker.blog/hecto</a></p>          </div><h2 id="安装Rust">安装Rust</h2><p>可以通过访问<a href="https://rustup.rs/">rustup</a>网站，它会尝试自动检测操作系统并显示安装 <code>rustup</code> 的最佳方法。通常，执行以下脚本 ，<code>rustup-init</code>会自动完成安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh<br></code></pre></td></tr></table></figure><p>当终端输出<code>Rust is installed now. Great!</code>时，代表<code>Rust</code>安装成功。这时候需要重启终端或者执行<code>source $HOME/.cargo/env</code>，就可以使用<code>Rust</code>了。</p><h3 id="检查安装">检查安装</h3><p>要验证<code>Rust</code>是否已正确安装，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustc --version<br></code></pre></td></tr></table></figure><p>要验证<code>Cargo</code>是否已正确安装，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo --version<br></code></pre></td></tr></table></figure><p>正常情况下，会得到程序名称、版本号和一些其他信息的输出。</p><h2 id="初始化iTEditor项目">初始化iTEditor项目</h2><p>在当前目录创建项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo init iTEditor<br></code></pre></td></tr></table></figure><p><code>iTEditor</code>是项目的名称（在<code>Rust</code>中，项目名称需要用<code>snake case</code>命名法，这个显然是不符合要求的，可以改成<code>i_text_editor</code>，我还是感觉我的好看，这里就不改了hh），执行完后会创建一个<code>iTEditor</code>文件夹，它已经设置好了<code>git</code>。</p><p>我们来查看一下目录结构：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  iTEditor git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.toml</span><br>└── <span class="hljs-attribute">src</span><br>    └── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span><br><br><span class="hljs-number">1</span> directory, <span class="hljs-number">2</span> files<br></code></pre></td></tr></table></figure><p>新的项目包含两个主要文件，其中<code>Cargo.toml</code>相当于<code>package.json</code>，主要记录当前项目所需要的依赖：</p><figure class="highlight rust"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">[package]<br>name = <span class="hljs-string">&quot;iTEditor&quot;</span><br>version = <span class="hljs-string">&quot;0.1.0&quot;</span><br>edition = <span class="hljs-string">&quot;2021&quot;</span><br><br># See more keys and their definitions at https:<span class="hljs-comment">//doc.rust-lang.org/cargo/reference/manifest.html</span><br><br>[dependencies]<br></code></pre></td></tr></table></figure><p>src/main.rs中包含了项目的源码：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译与运行">编译与运行</h3><p>在项目根文件夹中，运行<code>cargo build</code>进行编译，这将输出类似于以下内容：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">Compiling iTEditor v0<span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.0</span> (/root/iTEditor)<br> Finished dev <span class="hljs-selector-attr">[unoptimized + debuginfo]</span> <span class="hljs-built_in">target</span>(s) in <span class="hljs-number">0.10s</span><br></code></pre></td></tr></table></figure><p>这将生成一个名为<code>iTEditor</code>的可执行文件，并将其放置在名为<code>target/debug/</code>的新文件夹中。此外还有一个<code>Cargo.lock</code>文件，里面记录了每个库使用的精确的版本，不需要碰它。</p><p>在<code>target/debug/</code>目录中可以找到生成的可运行文件<code>iTEditor</code>，直接运行它，就会输出<code>Hello, world!</code>。</p><p>以上的步骤都可以通过<code>cargo run</code>来一步到位：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">   Compiling iTEditor v0.<span class="hljs-number">1.0</span> (<span class="hljs-regexp">/root/i</span>TEditor)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.13</span>s<br>     Running `target<span class="hljs-regexp">/debug/i</span>TEditor`<br>Hello, world!<br></code></pre></td></tr></table></figure><p>至此，就是一个<code>Rust</code>项目创建、编译与运行的所有流程了。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/e62fb29b.html">https://zone.ivan-zhang.com.cn/p/e62fb29b.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>TextEditor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144计算机网络Lab3: The TCP Sender</title>
    <link href="/p/785ad61c.html"/>
    <url>/p/785ad61c.html</url>
    
    <content type="html"><![CDATA[<center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/15/652c095ff0876.png" alt="CS144TCPSocket" style="zoom:25%;" /><br>  <font color="DimGray" size="3">The arrangement of modules and dataflow in TCP implementation.</font></center><p>在<code>Lab3</code>中，需要实现一个<code>TCPSender</code>，主要有以下几个功能：</p><ul><li>根据接收方的响应调整发送窗口；</li><li>发送<code>SYN</code>，<code>FIN</code>报文；</li><li>从<code>ByteStream</code>中读取、创建并发送新的<code>TCPSegment</code>；</li><li>跟踪已发送的<code>Segment</code>，直到被确认接收，必要时进行<code>超时重传</code>。</li></ul><h2 id="A-How-does-the-TCPSender-know-if-a-segment-was-lost">A. How does the TCPSender know if a segment was lost?</h2><blockquote><p>在<code>Lab0</code>中介绍过，<code>TCP</code>是在不可靠的链路上提供<strong>尽力而为</strong>的可靠传输。为了实现这一目的，在<code>TCP</code>中，<code>TCPSender</code>需要确保每一个<code>Segment</code>都被成功接收。</p></blockquote><p>每当一个<code>Segment</code>被发送出去，<code>TCPSender</code>会记录其发送的时间并标记为<strong>未完成的</strong>，当超过<code>retransmission timeout(RTO)</code>毫秒后，如果依然没有确认收到，就会进行重传。</p><h2 id="B-Implementing-the-TCP-sender">B. Implementing the TCP sender</h2><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/785ad61c.html">https://zone.ivan-zhang.com.cn/p/785ad61c.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144计算机网络Lab2: The TCP Receiver</title>
    <link href="/p/b9f66227.html"/>
    <url>/p/b9f66227.html</url>
    
    <content type="html"><![CDATA[<center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/15/652c095ff0876.png" alt="CS144TCPSocket" style="zoom:25%;" /><br>  <font color="DimGray" size="3">The arrangement of modules and dataflow in TCP implementation.</font></center>`Lab2`要求实现一个`TCPReceiver`，包含以下几个功能：<ul><li>接收<code>TCPSegment</code>；</li><li>调用字节流重组器；</li><li>向发送方发送相应确认信号；</li><li>流量控制。</li></ul><p>这次的实验主要分为<code>Translating between 64-bit indexes and 32-bit seqnos</code>和<code>Implementing the TCP receiver</code>两个部分。前者是学习实现<code>TCPSegment</code>中的索引方式；后者是实现<code>TCPReceiver</code>的主要功能。</p><h2 id="A-Translating-between-64-bit-indexes-and-32-bit-seqnos">A. Translating between 64-bit indexes and 32-bit seqnos</h2><p>这一部分需要实现<code>TCP</code>中表示索引的方式，在<a href="https://zone.ivan-zhang.com.cn/posts/5858.html"><code>Lab1</code></a>中我们实现了<code>StreamReassembler</code>，其中使用的<code>index</code>就是一个<code>64-bit</code> 并从<code>0</code>开始计数的<code>stream index</code>。然而<code>TCP</code>的首部空间寸土寸金，直接占用<code>64-bit</code>为免也太奢侈了，所以在实践中，通常使用<code>32-bit</code>的<code>sequence number</code>或<code>seqno</code>表示。这样一个用低位数据来表示高位数据的方法自然而然地又了了以下几个挑战：</p><ul><li>当<code>32-bit</code>空间用完<code>(到达2^32-1)</code>后，需要对其进行重置，从<code>0</code>开始重新计数，即<code>(mod 2^32)</code>；</li><li>为了避免以前连接中旧数据包造成混淆，在<code>TPC</code>连接建立阶段需要随机确定一个<code>32-bit</code>的初始值即<code>ISN(Initial Sequence Number)</code>，尽量保证序列号<strong>不可被预判</strong>或<strong>与之前重复</strong>；</li><li>为了保证开始信号、字节数据和数据结束信号可靠接收，在<code>TCP</code>中，<code>SYN(beginning of stream)</code>和<code>FIN(end of stream)</code>分别占用两个序列号，<code>SYN</code>占用第一个序列号也就是<code>ISN</code>，数据字节后续的序列号如<code>ISN+1 (mod 2^32)</code>、<code>ISN+2 (mod 2^32)</code>等等，最后<code>FIN</code>占用流后的一个序列号。</li></ul><p>在TCP中，索引有以下三种：</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/21/6532a9e34f0ef.png" alt="TCPIndex-Example" style="zoom:40%;" />  <br>  <font color="DimGray" size="3">An Example of Bitstream "cat".</font>  <br>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/21/6532aa42d64cf.png" alt="TCPIndex" style="zoom:40%;" />  <br>  <font color="DimGray" size="3">Three Different Types of Indexing Involved in TCP.</font></center><p>可以看到，absloute seqno与<code>stream index</code>之间非常好转换，而<code>seqno</code>与<code>absolute seqno</code>由于空间大小不一样，转换需要进行额外的操作。这一部分需要做的就是，根据头文件<code>wrapping integers.hh</code>完成<code>wrapping integers.cc</code>中的两个转换函数。</p><h3 id="Convert-absolute-seqno-→-seqno">Convert absolute seqno → seqno.</h3><p>对于<code>64-bit</code>的<code>absolute seqno</code>，先对它取模，确保在<code>32-bit</code>范围内，之后加上<code>ISN</code>再取模，得到<code>32-bit</code>的<code>seqno</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(n, isn);</span><br>        <span class="hljs-type">uint64_t</span> mod = <span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">32</span>;<br>        <span class="hljs-function">WrappingInt32 <span class="hljs-title">seqno</span> <span class="hljs-params">((n % mod + isn.raw_value()) % mod)</span></span>;<br>        <span class="hljs-keyword">return</span> seqno;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Convert-seqno-→-absolute-seqno">Convert seqno → absolute seqno.</h3><p>对于<code>32-bit</code>的<code>seqno</code>，需要找到距离checkpoint最近的absolute seqno，</p><ul><li>先确定<code>seqno</code>与ISN之间的偏移量；</li><li>在数轴上，位于<code>checkpoint</code>左侧的为<code>absolute_seqno_left</code>，右侧的为<code>absolute_seqno_right</code>，均初始化为<code>absolute_seqno_wrap</code>；</li><li>不断以<code>2^32</code>为单位增长<code>absolute_seqno_wrap</code>，直到<code>absolute_seqno_wrap &gt; checkpoint</code>，此时获取到了<code>absolute_seqno_left</code>与<code>absolute_seqno_right</code>，选取他们之中距离<code>checkpoint</code>最近的即为<code>absolute_seqno</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-type">uint64_t</span> checkpoint)</span> </span>&#123;<br>    <span class="hljs-comment">//    DUMMY_CODE(n, isn, checkpoint);</span><br>    <span class="hljs-type">uint64_t</span> mod = <span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>;<br>    <span class="hljs-type">uint64_t</span> absolute_seqno_wrap = n.<span class="hljs-built_in">raw_value</span>() - isn.<span class="hljs-built_in">raw_value</span>();<br>    <span class="hljs-type">uint64_t</span> absolute_seqno_right = absolute_seqno_wrap;<br>    <span class="hljs-type">uint64_t</span> absolute_seqno_left = absolute_seqno_wrap;<br>    <span class="hljs-keyword">while</span> (absolute_seqno_wrap &lt; checkpoint) &#123;<br>        absolute_seqno_wrap += mod;<br>        <span class="hljs-keyword">if</span> (absolute_seqno_wrap &lt; checkpoint)<br>            absolute_seqno_left = absolute_seqno_wrap;<br>        <span class="hljs-keyword">if</span> (absolute_seqno_wrap &gt; checkpoint)<br>            absolute_seqno_right = absolute_seqno_wrap;<br>    &#125;<br>    <span class="hljs-keyword">return</span> absolute_seqno_right - checkpoint &gt; checkpoint - absolute_seqno_left ? absolute_seqno_left<br>                                                                                : absolute_seqno_right;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改与改进">修改与改进</h3><p>在测试<code>test4</code>的时候遇到了问题：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span>/<span class="hljs-number">1</span> Test <span class="hljs-comment">#4: t_wrapping_ints_roundtrip ........***Failed    0.16 sec</span><br>Expected unwrap(wrap()) <span class="hljs-keyword">to</span> recover same value, <span class="hljs-keyword">and</span> <span class="hljs-keyword">it</span> didn&#x27;t!<br>  unwrap(wrap(value, isn), isn, checkpoint) did <span class="hljs-keyword">not</span> <span class="hljs-keyword">equal</span> value<br>  <span class="hljs-keyword">where</span> value = <span class="hljs-number">1383509345922390960</span>, isn = <span class="hljs-number">549282053</span>, <span class="hljs-keyword">and</span> checkpoint = <span class="hljs-number">1383509345922390960</span><br>  (Difference <span class="hljs-keyword">between</span> value <span class="hljs-keyword">and</span> checkpoint <span class="hljs-keyword">is</span> <span class="hljs-number">0.</span>)<br></code></pre></td></tr></table></figure><p>是因为没有考虑<code>absolute_seqno_wrap == checkpoint</code>的情况，于是增加了特判。除此之外为了防止<code>absolute_seqno_wrap</code>溢出增加了新的判定在<code>while() &#123;&#125;</code>中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (absolute_seqno_wrap &lt;= checkpoint) &#123;<br>        <span class="hljs-keyword">if</span> (UINT64_MAX - absolute_seqno_wrap &lt; mod || absolute_seqno_wrap == checkpoint)<br>            <span class="hljs-keyword">return</span> absolute_seqno_wrap;<br>        <span class="hljs-keyword">else</span><br>            absolute_seqno_wrap += mod;<br>        <span class="hljs-keyword">if</span> (absolute_seqno_wrap &lt; checkpoint)<br>            absolute_seqno_left = absolute_seqno_wrap;<br>        <span class="hljs-keyword">if</span> (absolute_seqno_wrap &gt; checkpoint)<br>            absolute_seqno_right = absolute_seqno_wrap;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后又跑了一下，在<code>test4</code>怎么也不出结果，以为有<code>死循环</code>，但是查了半天逻辑并无错误，看了一眼测试，，，跑<code>1000000</code>轮，原来只是<code>单纯的慢</code>罢了。</p><p><strong>那么如何改进，分析一下：</strong></p><p>前面的方案是通过循环累加确定<code>checkpoint</code>附近的<code>absolute seqno</code>，这个流程可以通过取模+除法操作替代，这就意味着计算未接近<code>checkpoint</code>的<code>32-bit</code>区间是毫无意义的，我们只需要考虑<code>checkpoint</code>所在的当前区间以及其前后区间即可。</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/24/653789844035c.png" alt="区间" style="zoom:17%;" />  <br>  <font color="DimGray" size="3">当前以及其前后32bit区间.</font></center><p>那么这样的话就有以下几种情况：</p><ul><li>在<code>checkpoint</code>与当前区间的<code>absolute seqno</code>重合时，<code>checkpoint</code>的位置就是<code>absolute seqno</code>；</li><li>当<code>checkpoint</code>的位置在当前区间中的<code>absolute seqno</code>的右侧时，会存在两个情况：<ul><li><code>checkpoint</code>在最后一个区间中，只有当前区间才有<code>absolute seqno</code>；</li><li><code>checkpoint</code>不在最后一个区间中，只有在当前区间和其后区间可能存在<code>absolute seqno</code>；</li></ul></li><li>当<code>checkpoint</code>的位置在当前区间中的<code>absolute seqno</code>的左侧时，也会存在两个情况：<ul><li><code>checkpoint</code>在第一个区间中，只有当前区间才有<code>absolute seqno</code>；</li><li><code>checkpoint</code>不在第一个区间中，只有在当前区间和前一个区间可能存在<code>absolute seqno</code>。</li></ul></li></ul><p>最后通过了测试的代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-type">uint64_t</span> checkpoint)</span> </span>&#123;<br>    <span class="hljs-comment">//    DUMMY_CODE(n, isn, checkpoint);</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> mod = <span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> checkpoint_32 = checkpoint % mod;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> absolute_n = n.<span class="hljs-built_in">raw_value</span>() - isn.<span class="hljs-built_in">raw_value</span>();<br>    <span class="hljs-keyword">if</span> (UINT64_MAX - checkpoint &lt; mod || absolute_n == checkpoint_32)<br>        <span class="hljs-keyword">return</span> (checkpoint / mod) * mod + absolute_n;<br>    <span class="hljs-keyword">if</span> (checkpoint_32 &gt; absolute_n)<br>        <span class="hljs-keyword">return</span> checkpoint_32 - absolute_n &gt; mod - checkpoint_32 + absolute_n<br>                   ? ((checkpoint / mod) + <span class="hljs-number">1</span>) * mod + absolute_n<br>                   : (checkpoint / mod) * mod + absolute_n;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (checkpoint &lt; mod)<br>            <span class="hljs-keyword">return</span> absolute_n;<br>        <span class="hljs-keyword">return</span> absolute_n - checkpoint_32 &gt; mod + checkpoint_32 - absolute_n<br>                   ? ((checkpoint / mod) - <span class="hljs-number">1</span>) * mod + absolute_n<br>                   : (checkpoint / mod) * mod + absolute_n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Implementing-the-TCP-receiver">B. Implementing the TCP receiver</h2><p><code>TCPReceiver</code>在运行过程中会收到这样格式的<code>TCPSegment</code>：</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/23/6535f5f09de27.png" alt="TCPSegment" style="zoom:75%;" />  <br>  <font color="DimGray" size="3">TCPSegment.</font></center><p>现在，需要根据<code>tcp_receiver.hh</code>来实现一下<code>TCPReceiver</code>：</p><p>首先需要增加三个变量：</p><ul><li><code>_isn</code>：储存存入第一次成功建立连接时的<code>seqno</code>；</li><li><code>_syn</code> ：判断连接是否建立；</li><li>_fin：判断连接是否终止。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPReceiver</span> &#123;<br>    <span class="hljs-comment">//! Our data structure for re-assembling bytes.</span><br>    StreamReassembler _reassembler;<br><br>    <span class="hljs-comment">//! The maximum number of bytes we&#x27;ll store.</span><br>    <span class="hljs-type">size_t</span> _capacity;<br><br>    WrappingInt32 _isn&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">bool</span> _syn = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> _fin = <span class="hljs-literal">false</span>;<br>  <br>  <span class="hljs-comment">/*codes*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>segment_received</code>的实现思路是：</p><ul><li>首先判断<code>seg.header().syn</code>是否为<code>true</code>且当前链接未建立时，设置<code>_isn</code>为<code>seqno</code>并建立连接，否则当链接不存在时，直接返回。</li><li>之后向<code>reassembler</code>中推送收到的<code>TCPSegment</code>中的数据；</li><li>最后当且仅当<code>seg.header().fin</code>为<code>true</code>时，将<code>_fin</code>记录为终止状态。</li></ul><p><code>ackno</code>的实现思路是：</p><ul><li>首先判断链接是否建立，如果为建立则直接返回<code>nullopt</code>；</li><li>如果建立了则返回下一个需要进行整合的<code>seqno</code>，从<code>absolute seqno</code>的角度来看即为 <code>_reassembler.stream_out().bytes_written() + 1</code>，同时需要注意<code>syn</code>与<code>fin</code>也会分别占用了一个seqno，</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPReceiver::segment_received</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPSegment &amp;seg)</span> </span>&#123;<br>    <span class="hljs-comment">//    DUMMY_CODE(seg);</span><br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().syn &amp;&amp; !_syn) &#123;<br>        _isn = seg.<span class="hljs-built_in">header</span>().seqno;<br>        _syn = seg.<span class="hljs-built_in">header</span>().syn;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!_syn) <span class="hljs-keyword">return</span>;<br>    _reassembler.<span class="hljs-built_in">push_substring</span>(seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">copy</span>(),<br>                                <span class="hljs-built_in">unwrap</span>(seg.<span class="hljs-built_in">header</span>().seqno, _isn, _reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>() + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span> +<br>                                    seg.<span class="hljs-built_in">header</span>().syn,<br>                                seg.<span class="hljs-built_in">header</span>().fin);<br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().fin) _fin = seg.<span class="hljs-built_in">header</span>().fin;<br>&#125;<br><br><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _syn ? optional&lt;WrappingInt32&gt;&#123;<span class="hljs-built_in">wrap</span>(_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>() + _syn + (_fin &amp;&amp; _reassembler.<span class="hljs-built_in">empty</span>()), _isn)&#125;<br>                : <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPReceiver::window_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _capacity - _reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">buffer_size</span>(); &#125;<br></code></pre></td></tr></table></figure><p>在写<code>segment_received</code>的时候，在<code>recv_specal</code>这个测试中卡了好久，这里面设计了很多<code>syn</code>、<code>fin</code>与数据结合的<code>Segment</code>，需要特别注意下。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/b9f66227.html">https://zone.ivan-zhang.com.cn/p/b9f66227.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144计算机网络Lab1: Stitching Substrings into a Byte Stream</title>
    <link href="/p/8eb2211f.html"/>
    <url>/p/8eb2211f.html</url>
    
    <content type="html"><![CDATA[<center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/15/652c095ff0876.png" alt="CS144TCPSocket" style="zoom:25%;" /><br>  <font color="DimGray" size="3">The arrangement of modules and dataflow in TCP implementation.</font></center>`Lab1`要求实现一个`StreamReassembler`，也就是接收端的`滑动窗口`，包含以下几个功能：<ul><li>将零散的字节流片段拼接成顺序正确的字节流；</li><li>忽略重复传输的数据包；</li><li>拒绝过早传输的数据包；</li><li>将排序好的字节流传递给上层的<code>ByteStream</code>。</li></ul><h2 id="A-Putting-substrings-in-sequence">A. Putting substrings in sequence</h2><p>在pdf中，作者给出了一个<code>StreamReassembler</code>的简单示意图，不过比较抽象</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/16/652ceff38d891.png" alt="StreamReassembler" style="zoom:65%;" /><br>  <font color="DimGray" size="3">StreamReassembler.</font></center><h3 id="首次尝试">首次尝试</h3><p>具体来说，对于外部输入随机排列的<code>substring</code>，使用滑动窗口处理陆续到达的<code>substring</code>并将它们全部储存在<code>buffer_string</code>中，其中滑动窗口是由<code>_reassembled_pt</code>和<code>_end_pt</code>两个指针组成，并保证<code>_end_pt - _reassembled_pt &lt;= _capacity</code>；同时维护一个<code>buffer_check</code>用来储存<code>buffer_string</code>中每个字节的占用情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamReassembler</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Your code here -- add private members as necessary.</span><br>    std::string buffer_string;<br>    std::string buffer_check;<br>    <span class="hljs-type">size_t</span> _reassembled_pt;<br>    <span class="hljs-type">size_t</span> _end_pt;<br>    <br>    <span class="hljs-comment">/*code*/</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">StreamReassembler::<span class="hljs-built_in">StreamReassembler</span>(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity) : <span class="hljs-built_in">buffer_string</span>(<span class="hljs-string">&quot;&quot;</span>), <span class="hljs-built_in">buffer_check</span>(<span class="hljs-string">&quot;&quot;</span>), _reassembled_pt(<span class="hljs-number">0</span>), _end_pt(<span class="hljs-number">-1</span>), _output(capacity), _capacity(capacity) &#123;&#125;<br></code></pre></td></tr></table></figure><p>对于<code>push_substring()</code>，<code>workflow</code>如下：</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/16/652d1588dde32.jpeg" alt="StreamReassembler" style="zoom:30%;" /><br>  <font color="DimGray" size="3">StreamReassembler.</font></center><ul><li>计算插入<code>data</code>后buffer_string的长度：<code>extended_length = index + data.length()</code>；</li><li>检查<code>extended_length</code>是否超出<code>capacity</code>，若超出则直接<code>return</code>；</li><li>检查<code>eof</code>是否为<code>true</code>，将<code>_end_pt</code>设置成<code>extended_length</code>；</li><li>将<code>buffer_string</code>和<code>buffer_check</code>的长度扩展到<code>extended_length</code>，并写入<code>data</code>同时将对应位置的<code>check</code>置为<code>1</code>；</li><li>如果<code>_reassembled_pt</code>位置上的比特非空，就写入到<code>ByteStream</code>，并右移<code>_reassembled_pt</code>直到遇到空位或<code>_reassembled_pt == _end_pt</code>；</li><li>当<code>_reassembled_pt == _end_pt</code>时，结束<code>ByteStream</code>输入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(data, index, eof);</span><br><br>    <span class="hljs-type">size_t</span> extended_length = index + data.<span class="hljs-built_in">length</span>();<br><br>    <span class="hljs-keyword">if</span> (extended_length &gt; _capacity)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (eof)<br>        _end_pt = extended_length;<br><br>    buffer_string.<span class="hljs-built_in">resize</span>(extended_length),<br>    buffer_check.<span class="hljs-built_in">resize</span>(extended_length),<br>    buffer_string.<span class="hljs-built_in">replace</span>(index,data.<span class="hljs-built_in">length</span>(),data);<br>    buffer_check.<span class="hljs-built_in">replace</span>(index,data.<span class="hljs-built_in">length</span>(),data.<span class="hljs-built_in">length</span>(),<span class="hljs-string">&#x27;1&#x27;</span>);<br><br>    <span class="hljs-keyword">while</span>(buffer_check[_reassembled_pt] &amp;&amp; _output.<span class="hljs-built_in">remaining_capacity</span>())&#123;<br>        _output.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">to_string</span>(buffer_string[_reassembled_pt]));<br>        _reassembled_pt++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_reassembled_pt == _end_pt)<br>        _output.<span class="hljs-built_in">end_input</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>unassembled_bytes()</code>函数，我们需要查看滑动窗口里未被连续填充的区间中填充byte的数量，也就是当<code>_reassembled_pt</code>处为空时，在其之后的<code>substring</code>数量，这里直接遍历一边就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">StreamReassembler::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> bytes_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = _reassembled_pt; i != buffer_check.<span class="hljs-built_in">length</span>(); i++)<br>        <span class="hljs-keyword">if</span>(buffer_check[i] == <span class="hljs-string">&#x27;1&#x27;</span>) bytes_cnt++;<br>    <span class="hljs-keyword">return</span> bytes_cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，判断<code>StreamReassembler</code>是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StreamReassembler::empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> !<span class="hljs-built_in">unassembled_bytes</span>(); &#125;<br></code></pre></td></tr></table></figure><p>然而，这个方案不能通过测试。</p><h3 id="进一步改进">进一步改进</h3><p>经过复盘发现了一些问题：</p><ol><li>当<code>extended_length</code>超过<code>_capacity</code>时就直接全部抛弃了，没有考虑部分输入的情况，正确的逻辑应该是仅抛弃无法写入的<code>unacceptable</code>字节；</li><li><code>eof</code>也没有考虑<code>unacceptable</code>字节的问题，需要对本次<code>data</code>是否能完整写入进行判定；</li><li>在写入<code>ByteStream</code>时，逐个进行的，并且进行了类型转换。</li><li>除此之外，在一开始进行分析的时候对<code>_reassembled_pt</code>和<code>_end_pt</code>的说明是<code>_end_pt - _reassembled_pt &lt;= _capacity</code>，忽略了<code>_end_pt</code>与<code>eof</code>的联系。</li></ol><p>经过修改新<code>workflow</code>如下：</p><ul><li>计算插入<code>data</code>后<code>buffer_string</code>的长度：<code>extended_length = index + data.length()</code>  ----&gt;<strong>插入长度</strong>；</li><li>计算符合<code>_capacity</code>要求理论最大长度：<code>max_expended_length = _reassembled_pt + _capacity</code>  ----&gt;<strong>最大长度</strong>；</li><li>检查<code>index</code>是否超出<code>capacity</code>，若超出则直接<code>return</code>；</li><li>检查<code>eof</code>是否为<code>true</code>，且如果本次的<code>data</code>能完全插入则令<code>_end_pt = expended_length</code>；</li><li>调整<code>buffer</code>并插入<code>data</code><ul><li>如果<strong>插入长度</strong>大于当前<code>buffer_string</code>的长度，则将<code>buffer_string</code>和<code>buffer_check</code>扩展到<strong>插入长度</strong>；</li><li>写入<code>data</code>同时将对应位置的<code>check</code>置为<code>1</code>；</li><li>如果插入后当前<code>buffer_string</code>的长度大于<strong>最大长度</strong>，则将<code>buffer_string</code>和<code>buffer_check</code>缩短到<strong>最大长度</strong>，抛弃掉<code>unacceptable</code>字节。</li></ul></li><li>如果<code>_reassembled_pt</code>位置上的比特非空，就写入到<code>ByteStream</code>，并右移<code>_reassembled_pt</code>直到遇到空位或<code>_output</code>已满；</li><li>当<code>_reassembled_pt == _end_pt</code>时，结束<code>ByteStream</code>输入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(data, index, eof);</span><br>    <span class="hljs-type">size_t</span> expended_length = index + data.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">size_t</span> max_expended_length = _reassembled_pt + _capacity;<br><br>    <span class="hljs-keyword">if</span> (index &gt; max_expended_length)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (eof &amp;&amp; expended_length &lt;= max_expended_length)<br>        _end_pt = expended_length;<br><br>    <span class="hljs-keyword">if</span> (expended_length &gt; buffer_string.<span class="hljs-built_in">length</span>()) &#123;<br>        buffer_string.<span class="hljs-built_in">resize</span>(expended_length);<br>        buffer_check.<span class="hljs-built_in">resize</span>(expended_length);<br>    &#125;<br><br>        buffer_string.<span class="hljs-built_in">replace</span>(index, data.<span class="hljs-built_in">length</span>(), data);<br>        buffer_check.<span class="hljs-built_in">replace</span>(index, data.<span class="hljs-built_in">length</span>(), data.<span class="hljs-built_in">length</span>(), <span class="hljs-string">&#x27;1&#x27;</span>);<br><br>    <span class="hljs-keyword">if</span> (buffer_string.<span class="hljs-built_in">length</span>() &gt; max_expended_length)&#123;<br>        buffer_string.<span class="hljs-built_in">resize</span>(max_expended_length);<br>        buffer_check.<span class="hljs-built_in">resize</span>(max_expended_length);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (buffer_check[_reassembled_pt] &amp;&amp; _output.<span class="hljs-built_in">remaining_capacity</span>())&#123;<br>        <span class="hljs-type">size_t</span> write_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(buffer_check[_reassembled_pt + write_len] &amp;&amp; _output.<span class="hljs-built_in">remaining_capacity</span>() - write_len) write_len++;<br>        _output.<span class="hljs-built_in">write</span>(buffer_string.<span class="hljs-built_in">substr</span>(_reassembled_pt,write_len));<br>        _reassembled_pt += write_len;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_reassembled_pt == _end_pt)<br>        _output.<span class="hljs-built_in">end_input</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过了<code>test</code>。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/8eb2211f.html">https://zone.ivan-zhang.com.cn/p/8eb2211f.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144计算机网络Lab0: Networking Warmup</title>
    <link href="/p/30fba476.html"/>
    <url>/p/30fba476.html</url>
    
    <content type="html"><![CDATA[<p>热身分为三个部分，第一部分要求用<code>telnet</code>工具来发送一些简单的http请求，第二部分是写一个简单的<code>webget</code>应用模拟使用<code>telnet</code>是的操作，第三部分是完善一个<code>ByteStream</code>来实现更底层的<code>socket</code>写入读取等操作</p><h2 id="第一部分-Networking-by-hand">第一部分 - Networking by hand</h2><h3 id="A-Fetch-a-Web-page">A. Fetch a Web page</h3><p>通过在浏览器中访问<code>http://cs144.keithw.org/hello</code>，我们得到一条信息<code>Hello, CS144!</code>，现在让我们用<code>telnet</code>来实现这个过程：</p><ul><li><p>首先需要通过<code>telnet</code>与<code>cs144.keithw.org</code>建立<code>reliable byte stream</code>，并告诉对方我们我们接下来的请求将使用<code>http</code>协议：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ telnet cs144.keithw.org http<br>Trying 198.18.0.30...<br>Connected to cs144.keithw.org.<br>Escape character is &#x27;^]&#x27;.<br></code></pre></td></tr></table></figure></li></ul><p>​现在我们就可以发送请求了</p><ul><li><p>继续发送</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/hello</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>cs144.keithw.org<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br></code></pre></td></tr></table></figure><p>值得注意的是，服务器需要在超时之前接收到请求，我刚开始的时候一行一行地输入，由于打字速度感人，就会由于超时而收到<code>Connection closed by foreign host.</code>。除此之外，再写好请求后需要多按两次回车告诉<code>telnet</code>发送该请求。</p></li><li><p>最后我们得到了理想的返回响应</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Sun, 15 Oct 2023 04:38:14 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Thu, 13 Dec 2018 15:45:29 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;e-57ce93446cb64&quot;<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>14<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><br><span class="language-pgsql">Hello, CS144!</span><br><span class="language-pgsql"><span class="hljs-keyword">Connection</span> closed <span class="hljs-keyword">by</span> <span class="hljs-keyword">foreign</span> host.</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="Assignment">Assignment</h4><p>最后有一个任务，要求从<code>http://cs144.keithw.org/lab0/sunetid</code>获取<code>secret code</code>，这个就非常的简单了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ telnet cs144.keithw.org http<br>Trying 198.18.0.30...<br>Connected to cs144.keithw.org.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>GET /lab0/0001 HTTP/1.1<br>Host: cs144.keithw.org<br>Connection: close<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Sun, 15 Oct 2023 04:47:40 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache<br><span class="hljs-attribute">X-You-Said-Your-SunetID-Was</span><span class="hljs-punctuation">: </span>0001<br><span class="hljs-attribute">X-Your-Code-Is</span><span class="hljs-punctuation">: </span>427826<br><span class="hljs-attribute">Content-length</span><span class="hljs-punctuation">: </span>108<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><br><span class="language-applescript">Hello! You told us <span class="hljs-keyword">that</span> your SUNet ID was <span class="hljs-string">&quot;0001&quot;</span>. Please see <span class="hljs-keyword">the</span> HTTP headers (<span class="hljs-keyword">above</span>) <span class="hljs-keyword">for</span> your secret code.</span><br><span class="language-applescript">Connection closed <span class="hljs-keyword">by</span> foreign host.</span><br></code></pre></td></tr></table></figure><h3 id="B-Send-yourself-an-email"><s>B.Send yourself an email</s></h3><h3 id="C-Listening-and-connecting">C. Listening and connecting</h3><p>在上面我们使用<code>telnet</code>向服务器发送请求，现在我们将成为一个简单的服务器，接受外部的信息</p><ul><li><p>使用<code>netcat</code>监听9090端口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ netcat -v -l -p 9090<br>Listening on 0.0.0.0 9090<br></code></pre></td></tr></table></figure></li><li><p>在另一个终端中运行<code>telnet</code>，连接到本地的<code>9090</code>端口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ telnet localhost 9090<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br></code></pre></td></tr></table></figure></li><li><p>现在，我们可以在两个终端之间互相发送信息了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ netcat -v -l -p 9090<br>Listening on 0.0.0.0 9090<br>Connection received on localhost 60162<br>hello, this is Ivan, <span class="hljs-built_in">bye</span>~<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ telnet localhost 9090<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>hello, this is Ivan, <span class="hljs-built_in">bye</span>~<br></code></pre></td></tr></table></figure></li></ul><h2 id="第二部分-Writing-a-network-program-using-an-OS-stream-socket">第二部分 - Writing a network program using an OS stream socket</h2><p>这一部分需要通过系统内建的<code>stream socket</code>写一个简单的<code>webget</code>来实现之前<code>telnet</code>,具体来说，需要完善<code>apps/webget.cc</code>中的<code>get_URL</code>函数。我们可以参考<code>doctests/address_example_1.cc</code>和<code>doctests/socket_example_2.cc</code>，实际上就是初始化一个<code>TCPSocket</code>并通过目标<code>Address</code>建立连接，之后向服务求发送之前类似的请求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Your code here.</span><br><br>TCPSocket con;<br>con.<span class="hljs-built_in">connect</span>(<span class="hljs-built_in">Address</span>(host, <span class="hljs-string">&quot;http&quot;</span>));<br>con.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\n&quot;</span>);<br>con.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Host: &quot;</span> + host + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>con.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Connection: close\r\n&quot;</span>);<br>con.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><br><span class="hljs-keyword">while</span>(!con.<span class="hljs-built_in">eof</span>())&#123;<br>    cout &lt;&lt; con.<span class="hljs-built_in">read</span>();<br>&#125;<br>con.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><p>在<code>Connection: close\r\n</code>之后，仍然需要写入一个<code>回车</code>告诉<code>socket</code>可以发送了，不然会一直等待直到超时。</p><p>测试一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  build git:(main) ✗ make check_webget<br>[100%] Testing webget...<br>Test project /root/CS144Learn/build<br>    Start 31: t_webget<br>1/1 Test <span class="hljs-comment">#31: t_webget .........................   Passed    1.30 sec</span><br><br>100% tests passed, 0 tests failed out of 1<br><br>Total Test time (real) =   1.32 sec<br>[100%] Built target check_webget<br></code></pre></td></tr></table></figure><h2 id="第三部分-An-in-memory-reliable-byte-stream">第三部分 - An in-memory reliable byte stream</h2><p>这一部分要求我们根据<code>pdf</code>中<code>writer</code>和<code>reader</code>的接口来完善<code>libsponge/byte stream.hh</code>和<code>libsponge/byte stream.cc</code>，并能处理比<code>buffer</code>容量要长的多的字节流。</p><p><code>byte stream.hh</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteStream</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Your code here -- add private members as necessary.</span><br>    std::string string_buffer;<br>    <span class="hljs-type">size_t</span> _buffer_size;<br>    <span class="hljs-type">size_t</span> _bytes_written;<br>    <span class="hljs-type">size_t</span> _bytes_read;<br><span class="hljs-comment">//    bool _buffer_empty = false;</span><br>    <span class="hljs-type">bool</span> _is_input_ended = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">/*code*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>byte stream.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++">ByteStream::<span class="hljs-built_in">ByteStream</span>(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity) : <span class="hljs-built_in">string_buffer</span>(<span class="hljs-string">&quot;&quot;</span>), _buffer_size(capacity), _bytes_written(<span class="hljs-number">0</span>), _bytes_read(<span class="hljs-number">0</span>) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::write</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(data);</span><br>    <span class="hljs-type">size_t</span> write_cnt = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">remaining_capacity</span>(), data.<span class="hljs-built_in">length</span>());<br>    string_buffer += std::<span class="hljs-built_in">move</span>(data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,write_cnt));<br>    _bytes_written += write_cnt;<br><br>    <span class="hljs-keyword">return</span> write_cnt;<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be copied from the output side of the buffer</span><br><span class="hljs-function">string <span class="hljs-title">ByteStream::peek_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(len);</span><br>    <span class="hljs-keyword">return</span> string_buffer.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,len);<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be removed from the output side of the buffer</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ByteStream::pop_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(len);</span><br>    string_buffer.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>,len);<br>    _bytes_read+=len;<br>&#125;<br><br><span class="hljs-comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span><br><span class="hljs-comment">//! \param[in] len bytes will be popped and returned</span><br><span class="hljs-comment">//! \returns a string</span><br><span class="hljs-function">std::string <span class="hljs-title">ByteStream::read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">//    DUMMY_CODE(len);</span><br>    std::string copied_str = <span class="hljs-built_in">peek_output</span>(len);<br>    <span class="hljs-built_in">pop_output</span>(len);<br><br>    <span class="hljs-keyword">return</span> copied_str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ByteStream::end_input</span><span class="hljs-params">()</span> </span>&#123; _is_input_ended = <span class="hljs-literal">true</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::input_ended</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_input_ended; &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::buffer_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> string_buffer.<span class="hljs-built_in">length</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> string_buffer.<span class="hljs-built_in">empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::eof</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_input_ended &amp;&amp; <span class="hljs-built_in">buffer_empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::bytes_written</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _bytes_written; &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::bytes_read</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _bytes_read; &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _buffer_size - <span class="hljs-built_in">buffer_size</span>(); &#125;<br></code></pre></td></tr></table></figure><p>在一开始做这个实验的时候，完全不知道需要干什么，之前学的C++还有面向对象的知识都忘了不少。实际上只需要按照每个模块的功能一步步写+<code>debug</code>就好了。</p><p>在测试的时候经常会出现<code>The ByteStream should have had bytes_written equal to 0 but instead it was 1</code>这样的错误，后面发现是我在定义<code>string_buffer</code>的时候把它初始化为了<code>&quot; &quot;</code>，而正常应该是为<code>空</code>。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/30fba476.html">https://zone.ivan-zhang.com.cn/p/30fba476.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
