<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust学习-制作一个文本编辑器: A Text Viewer</title>
    <link href="/p/c5a87dbb.html"/>
    <url>/p/c5a87dbb.html</url>
    
    <content type="html"><![CDATA[<h2 id="显示行">显示行</h2><p>我们需要一个额外的数据结构：<code>Document</code>，代表用户当前正在编辑的文档，以及文档中的<code>Row</code>。</p><figure class="highlight diff"><figcaption><span>src/document.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -0,0 +1,6 @@</span><br><span class="hljs-addition">+use crate::Row;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+#[derive(Default)]</span><br><span class="hljs-addition">+pub struct Document &#123;</span><br><span class="hljs-addition">+    rows: Vec&lt;Row&gt;,</span><br><span class="hljs-addition">+&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,5 +1,6 @@</span><br> use crate::Terminal;<br> use termion::event::Key;<br><span class="hljs-addition">+use crate::Document;</span><br> <br> const VERSION: &amp;str = env!(&quot;CARGO_PKG_VERSION&quot;);<br> <br><span class="hljs-meta">@@ -11,6 +12,7 @@</span> pub struct Editor &#123;<br>     should_quit: bool,<br>     terminal: Terminal,<br>     cursor_position: Position,<br><span class="hljs-addition">+    document: Document,</span><br> &#125;<br> <br> impl Editor &#123;<br><span class="hljs-meta">@@ -33,6 +35,7 @@</span> impl Editor &#123;<br>             should_quit: false,<br>             terminal: Terminal::default().expect(&quot;Failed to initialize terminal&quot;),<br>             cursor_position: Position &#123; x: 0, y: 0 &#125;,<br><span class="hljs-addition">+            document: Document::default(),</span><br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -2,10 +2,14 @@</span><br> <br> mod editor;<br> mod terminal;<br><span class="hljs-addition">+mod row;</span><br><span class="hljs-addition">+mod document;</span><br> <br> use editor::Editor;<br> pub use terminal::Terminal;<br> pub use editor::Position;<br><span class="hljs-addition">+pub use row::Row;</span><br><span class="hljs-addition">+pub use document::Document;</span><br> <br> fn main() &#123;<br>     Editor::default().run()<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/row.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">+pub struct Row &#123;</span><br><span class="hljs-addition">+    string: String</span><br><span class="hljs-addition">+&#125;</span><br></code></pre></td></tr></table></figure><p>在这里，我们为代码引入了两个新概念。首先，我们使用了一个叫做<code>Vector</code>的数据结构来存放我们的行。<code>Vector</code>是一种动态结构：它可以在运行时增长或缩小，因为我们在添加或删除元素。<code>Vec&lt;Row&gt;</code>这一语法意味着这个向量将会存放<code>Row</code>类型的元素。</p><p>另一个是这行代码：<code>#[derive(Default)]</code>。它表示<code>Rust</code>编译器应该为<code>default</code>派生一个实现。<code>default</code>应该返回一个其内容初始化为默认值的结构体——这是编译器可以为我们做的。<strong>有了这个指令，我们就不需要自己实现<code>default</code>了。</strong></p><p>现在我们可以简化一下我们的代码：</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -4,6 +4,7 @@</span> use crate::Document;<br> <br> const VERSION: &amp;str = env!(&quot;CARGO_PKG_VERSION&quot;);<br> <br><span class="hljs-addition">+#[derive(Default)]</span><br> pub struct Position &#123;<br>     pub x: usize,<br>     pub y: usize,<br><span class="hljs-meta">@@ -34,7 +35,7 @@</span> impl Editor &#123;<br>         Self &#123;<br>             should_quit: false,<br>             terminal: Terminal::default().expect(&quot;Failed to initialize terminal&quot;),<br><span class="hljs-deletion">-            cursor_position: Position &#123; x: 0, y: 0 &#125;,</span><br><span class="hljs-addition">+            cursor_position: Position::default(),</span><br>             document: Document::default(),<br>         &#125;<br>     &#125;<br><span class="hljs-meta">@@ -42,7 +43,7 @@</span> impl Editor &#123;<br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br>         Terminal::cursor_hide();<br>         Terminal::clear_screen();<br><span class="hljs-deletion">-        Terminal::cursor_position(&amp;Position &#123; x: 0, y: 0 &#125;);</span><br><span class="hljs-addition">+        Terminal::cursor_position(&amp;Position::default());</span><br>         if self.should_quit &#123;<br>             Terminal::clear_screen();<br>             println!(&quot;Goodbye.\r&quot;);<br></code></pre></td></tr></table></figure><p>通过为<code>Position</code>派生<code>default</code>，我们消除了将光标位置初始化为<code>(0, 0)</code>的重复代码。如果将来我们决定以不同的方式初始化<code>Position</code>，我们可以自己实现<code>default</code>而不需要触及其他代码。</p><p>我们不能为其他更复杂的结构体派生<code>default</code>——<code>Rust</code>无法猜测所有结构体成员的默认值。</p><p>让我们在<code>Document</code>中填充一些文本。我们目前不用考虑从文件中读取内容，现在，我们将直接编写一个<code>&quot;Hello, World&quot;</code>字符串到其中。</p><figure class="highlight diff"><figcaption><span>src/document.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -3,4 +3,12 @@</span> use crate::Row;<br> #[derive(Default)]<br> pub struct Document &#123;<br>     rows: Vec&lt;Row&gt;,<br><span class="hljs-deletion">-&#125;</span><br>\ No newline at end of file<br><span class="hljs-addition">+&#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+impl Document &#123;</span><br><span class="hljs-addition">+    pub fn open() -&gt; Self &#123;</span><br><span class="hljs-addition">+        let mut rows = Vec::new();</span><br><span class="hljs-addition">+        rows.push(Row::from(&quot;Hello, World!&quot;));</span><br><span class="hljs-addition">+        Self &#123; rows &#125;</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -36,7 +36,7 @@</span> impl Editor &#123;<br>             should_quit: false,<br>             terminal: Terminal::default().expect(&quot;Failed to initialize terminal&quot;),<br>             cursor_position: Position::default(),<br><span class="hljs-deletion">-            document: Document::default(),</span><br><span class="hljs-addition">+            document: Document::open(),</span><br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/row.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,3 +1,11 @@</span><br> pub struct Row &#123;<br><span class="hljs-deletion">-    string: String</span><br><span class="hljs-addition">+    string: String,</span><br><span class="hljs-addition">+&#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+impl From&lt;&amp;str&gt; for Row &#123;</span><br><span class="hljs-addition">+    fn from(slice: &amp;str) -&gt; Self &#123;</span><br><span class="hljs-addition">+        Self &#123;</span><br><span class="hljs-addition">+            string: String::from(slice),</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><p>在<code>from</code>函数中，我们使用了<code>From</code>特性，它允许类型定义如何从另一种类型创建自身，从而提供了一种非常简单的机制来在多种类型之间进行转换。</p><p>之后我们会实现一个从文件打开<code>Document</code>的方法，我们会再次使用1来初始化我们的<code>editor</code>。但现在，让我们先关注如何显示。</p><figure class="highlight diff"><figcaption><span>src/document.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -11,4 +11,7 @@</span> impl Document &#123;<br>         rows.push(Row::from(&quot;Hello, World!&quot;));<br>         Self &#123; rows &#125;<br>     &#125;<br><span class="hljs-addition">+    pub fn row(&amp;self, index: usize) -&gt; Option&lt;&amp;Row&gt; &#123;</span><br><span class="hljs-addition">+        self.rows.get(index)</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,6 +1,7 @@</span><br><span class="hljs-addition">+use crate::Document;</span><br><span class="hljs-addition">+use crate::Row;</span><br> use crate::Terminal;<br> use termion::event::Key;<br><span class="hljs-deletion">-use crate::Document;</span><br> <br> const VERSION: &amp;str = env!(&quot;CARGO_PKG_VERSION&quot;);<br> <br><span class="hljs-meta">@@ -101,9 +102,11 @@</span> impl Editor &#123;<br> <br>     fn draw_rows(&amp;self) &#123;<br>         let height = self.terminal.size().height;<br><span class="hljs-deletion">-        for row in 0..height - 1 &#123;</span><br><span class="hljs-addition">+        for terminal_row in 0..height - 1 &#123;</span><br>             Terminal::clear_current_line();<br><span class="hljs-deletion">-            if row == height / 3 &#123;</span><br><span class="hljs-addition">+            if let Some(row) = self.document.row(terminal_row as usize) &#123;</span><br><span class="hljs-addition">+                self.draw_row(row);</span><br><span class="hljs-addition">+            &#125; else if terminal_row == height / 3 &#123;</span><br>                 self.draw_welcome_message();<br>             &#125; else &#123;<br>                 println!(&quot;~\r&quot;)<br><span class="hljs-meta">@@ -121,6 +124,13 @@</span> impl Editor &#123;<br>         welcome_message.truncate(width);<br>         println!(&quot;&#123;&#125;\r&quot;, welcome_message);<br>     &#125;<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn draw_row(&amp;self, row: &amp;Row) &#123;</span><br><span class="hljs-addition">+        let start = 0;</span><br><span class="hljs-addition">+        let end = self.terminal.size().width as usize;</span><br><span class="hljs-addition">+        let row = row.render(start, end);</span><br><span class="hljs-addition">+        println!(&quot;&#123;&#125;\r&quot;, row)</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/row.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,3 +1,5 @@</span><br><span class="hljs-addition">+use std::cmp;</span><br><span class="hljs-addition">+</span><br> pub struct Row &#123;<br>     string: String,<br> &#125;<br><span class="hljs-meta">@@ -9,3 +11,11 @@</span> impl From&lt;&amp;str&gt; for Row &#123;<br>         &#125;<br>     &#125;<br> &#125;<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+impl Row &#123;</span><br><span class="hljs-addition">+    pub fn render (&amp;self, start: usize, end: usize) -&gt;String &#123;</span><br><span class="hljs-addition">+        let end = cmp::min(end,self.string.len());</span><br><span class="hljs-addition">+        let start = cmp::min(start,end);</span><br><span class="hljs-addition">+        self.string.get(start..end).unwrap_or_default().to_string()</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+&#125;</span><br></code></pre></td></tr></table></figure><p>我们为<code>Row</code>其添加了一个名为<code>render</code>的方法，它会返回它能生成的最大可能的子字符串。我们也使用了<code>unwrap_or_default</code>，尽管这里不是必需的，因为我们已经事先清理了起始和结束参数。最后一行的操作是我们尝试从字符串中创建一个子字符串，<strong>并将其转换成字符串</strong>，或者转换成默认值<code>（&quot;&quot;）</code>。在<code>Rust</code>中，<code>String</code>和<code>str</code>是有区别的。</p><p>在<code>Document</code>中，我们添加了一个方法来检索特定索引处的<code>Row</code>。我们使用<code>Vector</code>的<code>get</code>方法：如果索引超出范围则返回<code>None</code>，否则返回拥有的<code>Row</code>。</p><p>现在让我们看<code>Editor</code>。在<code>draw_rows</code>中，我们首先将变量<code>row</code>重命名为<code>terminal_row</code>以避免与我们现在从<code>Document</code>中获取的行混淆。然后我们检索<code>row</code>并显示它。<code>Row</code>确保返回一个可以显示的子字符串，而<code>Editor</code>确保满足终端尺寸的要求。</p><p>然而，我们的欢迎消息仍然被显示出来。当用户打开一个文件时，我们不希望显示这个消息，所以让我们为<code>Document</code>添加一个<code>is_empty</code>方法，并在<code>draw_rows</code>中检查它。</p><figure class="highlight diff"><figcaption><span>src/document.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -14,4 +14,7 @@</span> impl Document &#123;<br>     pub fn row(&amp;self, index: usize) -&gt; Option&lt;&amp;Row&gt; &#123;<br>         self.rows.get(index)<br>     &#125;<br><span class="hljs-addition">+    pub fn is_empty(&amp;self) -&gt; bool &#123;</span><br><span class="hljs-addition">+        self.rows.is_empty()</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -106,7 +106,7 @@</span> impl Editor &#123;<br>             Terminal::clear_current_line();<br>             if let Some(row) = self.document.row(terminal_row as usize) &#123;<br>                 self.draw_row(row);<br><span class="hljs-deletion">-            &#125; else if terminal_row == height / 3 &#123;</span><br><span class="hljs-addition">+            &#125; else if self.document.is_empty() &amp;&amp; terminal_row == height / 3 &#123;</span><br>                 self.draw_welcome_message();<br>             &#125; else &#123;<br>                 println!(&quot;~\r&quot;)<br></code></pre></td></tr></table></figure><p>现在屏幕中间不再显示那条消息了。接下来，让我们允许用户打开并显示实际文件。我们从修改<code>Document</code>开始：</p><figure class="highlight diff"><figcaption><span>src/document.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,4 +1,5 @@</span><br> use crate::Row;<br><span class="hljs-addition">+use std::fs;</span><br> <br> #[derive(Default)]<br> pub struct Document &#123;<br><span class="hljs-meta">@@ -6,10 +7,13 @@</span> pub struct Document &#123;<br> &#125;<br> <br> impl Document &#123;<br><span class="hljs-deletion">-    pub fn open() -&gt; Self &#123;</span><br><span class="hljs-addition">+    pub fn open(filename: &amp;str) -&gt; Result&lt;Self, std::io::Error&gt; &#123;</span><br><span class="hljs-addition">+        let contents = fs::read_to_string(filename)?;</span><br>         let mut rows = Vec::new();<br><span class="hljs-deletion">-        rows.push(Row::from(&quot;Hello, World!&quot;));</span><br><span class="hljs-deletion">-        Self &#123; rows &#125;</span><br><span class="hljs-addition">+        for value in contents.lines() &#123;</span><br><span class="hljs-addition">+            rows.push(Row::from(value));</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+        Ok(Self &#123; rows &#125;)</span><br>     &#125;<br>     pub fn row(&amp;self, index: usize) -&gt; Option&lt;&amp;Row&gt; &#123;<br>         self.rows.get(index)<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -37,7 +37,7 @@</span> impl Editor &#123;<br>             should_quit: false,<br>             terminal: Terminal::default().expect(&quot;Failed to initialize terminal&quot;),<br>             cursor_position: Position::default(),<br><span class="hljs-deletion">-            document: Document::open(),</span><br><span class="hljs-addition">+            document: Document::default(),</span><br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><p>我们目前在启动时使用一个默认的<code>Document</code>，并更新了<code>open</code>方法，该方法尝试打开一个文件，并在失败时返回错误。<code>open</code>将行读入我们的<code>Document</code>结构体。需要注意的是，<code>rows</code>中的每一行都不会包含行结束符<code>\n</code>或者<code>\r\n</code>，因为<code>Rust</code>的<code>line()</code>方法会剪切掉它们。</p><p>现在让我们实际使用<code>open</code>来打开一个文件，这个文件将通过命令行传递给<code>iTEditor</code>。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,6 +1,7 @@</span><br> use crate::Document;<br> use crate::Row;<br> use crate::Terminal;<br><span class="hljs-addition">+use std::env;</span><br> use termion::event::Key;<br> <br> const VERSION: &amp;str = env!(&quot;CARGO_PKG_VERSION&quot;);<br><span class="hljs-meta">@@ -33,11 +34,19 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     pub fn default() -&gt; Self &#123;<br><span class="hljs-addition">+        let args: Vec&lt;String&gt; = env::args().collect();</span><br><span class="hljs-addition">+        let document = if args.len() &gt; 1 &#123;</span><br><span class="hljs-addition">+            let file_name = &amp;args[1];</span><br><span class="hljs-addition">+            Document::open(&amp;file_name).unwrap_or_default()</span><br><span class="hljs-addition">+        &#125; else &#123;</span><br><span class="hljs-addition">+            Document::default()</span><br><span class="hljs-addition">+        &#125;;</span><br><span class="hljs-addition">+</span><br>         Self &#123;<br>             should_quit: false,<br>             terminal: Terminal::default().expect(&quot;Failed to initialize terminal&quot;),<br>             cursor_position: Position::default(),<br><span class="hljs-deletion">-            document: Document::default(),</span><br><span class="hljs-addition">+            document,</span><br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><h2 id="滚动浏览">滚动浏览</h2><p>现在，我们希望能够滚动浏览整个文件，而不仅仅是看到文件的前几行。让我们给编辑器状态添加一个偏移量<code>offset</code>，用以追踪用户当前滚动到文件的哪一行。我们将复用<code>Position</code>结构体。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -16,6 +16,7 @@</span> pub struct Editor &#123;<br>     terminal: Terminal,<br>     cursor_position: Position,<br>     document: Document,<br><span class="hljs-addition">+    offset: Position,</span><br> &#125;<br> <br> impl Editor &#123;<br><span class="hljs-meta">@@ -47,6 +48,7 @@</span> impl Editor &#123;<br>             terminal: Terminal::default().expect(&quot;Failed to initialize terminal&quot;),<br>             cursor_position: Position::default(),<br>             document,<br><span class="hljs-addition">+            offset: Position::default(),</span><br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><p>用<code>defult</code>来初始化它，这意味着默认情况下文件会滚动到左上角。</p><p>现在，让我们修改<code>draw_row()</code>函数，使其能够根据<code>offset.x</code>的值显示文件正确的行范围，同时让<code>draw_rows()</code>函数根据<code>offset.y</code>的值显示正确的行数范围。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -115,7 +115,7 @@</span> impl Editor &#123;<br>         let height = self.terminal.size().height;<br>         for terminal_row in 0..height - 1 &#123;<br>             Terminal::clear_current_line();<br><span class="hljs-deletion">-            if let Some(row) = self.document.row(terminal_row as usize) &#123;</span><br><span class="hljs-addition">+            if let Some(row) = self.document.row(terminal_row as usize + self.offset.y) &#123;</span><br>                 self.draw_row(row);<br>             &#125; else if self.document.is_empty() &amp;&amp; terminal_row == height / 3 &#123;<br>                 self.draw_welcome_message();<br><span class="hljs-meta">@@ -137,8 +137,9 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     pub fn draw_row(&amp;self, row: &amp;Row) &#123;<br><span class="hljs-deletion">-        let start = 0;</span><br><span class="hljs-deletion">-        let end = self.terminal.size().width as usize;</span><br><span class="hljs-addition">+        let start = self.offset.x;</span><br><span class="hljs-addition">+        let width = self.terminal.size().width as usize;</span><br><span class="hljs-addition">+        let end = self.offset.x + width;</span><br>         let row = row.render(start, end);<br>         println!(&quot;&#123;&#125;\r&quot;, row)<br>     &#125;<br></code></pre></td></tr></table></figure><p>我们将偏移量添加到字符串的开始和结束位置，以获得我们所需的字符串切片。我们也确保了在字符串长度不足以填充屏幕时的情况能得到处理。如果当前行在屏幕左侧结束（如果我们在一行很长的行中滚动到右侧时可能会发生），<code>Row</code>的<code>render</code>方法将返回一个空字符串。</p><p>我们在哪里设置<code>offset</code>的值呢？我们的策略将是检查光标是否已移动到可见窗口之外，如果是的话，就调整<code>offset</code>以使光标正好在可见窗口内。我们将这个逻辑放在一个名为<code>scroll</code>的函数中，并在处理按键后立即调用它。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -81,6 +81,7 @@</span> impl Editor &#123;<br>             | Key::PageDown =&gt; self.move_cursor(pressed_key),<br>             _ =&gt; (),<br>         &#125;<br><span class="hljs-addition">+        self.scroll();</span><br>         Ok(())<br>     &#125;<br> <br><span class="hljs-meta">@@ -143,6 +144,23 @@</span> impl Editor &#123;<br>         let row = row.render(start, end);<br>         println!(&quot;&#123;&#125;\r&quot;, row)<br>     &#125;<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn scroll(&amp;mut self) &#123;</span><br><span class="hljs-addition">+        let Position &#123; x, y &#125; = self.cursor_position;</span><br><span class="hljs-addition">+        let width = self.terminal.size().width as usize;</span><br><span class="hljs-addition">+        let height = self.terminal.size().height as usize;</span><br><span class="hljs-addition">+        let offset = &amp;mut self.offset;</span><br><span class="hljs-addition">+        if y &lt; offset.y &#123;</span><br><span class="hljs-addition">+            offset.y = y;</span><br><span class="hljs-addition">+        &#125; else if y &gt;= offset.y.saturating_add(height) &#123;</span><br><span class="hljs-addition">+            offset.y = y.saturating_sub(height).saturating_add(1);</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+        if x &lt; offset.x &#123;</span><br><span class="hljs-addition">+            offset.x = x;</span><br><span class="hljs-addition">+        &#125; else if x &gt;= offset.x.saturating_add(width) &#123;</span><br><span class="hljs-addition">+            offset.x = x.saturating_sub(width).saturating_add(1);</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><p>要使用<code>scroll</code>函数，我们需要知道终端的宽度和高度以及当前位置，并且我们想要在<code>self.offset</code>中更改值。如果我们已经向左或向上移动，我们想要将我们的偏移设置为文档中的新位置。如果我们向右滚动得太远，我们将从新位置减去当前偏移来计算新偏移。</p><p>现在，让我们允许光标超过屏幕底部前进（但不超过文件底部）。</p><figure class="highlight diff"><figcaption><span>src/document.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -21,4 +21,7 @@</span> impl Document &#123;<br>     pub fn is_empty(&amp;self) -&gt; bool &#123;<br>         self.rows.is_empty()<br>     &#125;<br><span class="hljs-addition">+    pub fn len(&amp;self) -&gt; usize &#123;</span><br><span class="hljs-addition">+        self.rows.len()</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -88,7 +88,7 @@</span> impl Editor &#123;<br>     fn move_cursor(&amp;mut self, key: Key) &#123;<br>         let Position &#123; mut x, mut y &#125; = self.cursor_position;<br>         let size = self.terminal.size();<br><span class="hljs-deletion">-        let height = size.height.saturating_sub(1) as usize;</span><br><span class="hljs-addition">+        let height = self.document.len();</span><br>         let width = size.width.saturating_sub(1) as usize;<br>         match key &#123;<br>             Key::Up =&gt; y = y.saturating_sub(1),<br></code></pre></td></tr></table></figure><p>现在，当你运行<code>cargo run Cargo.lock</code>时，就能够滚动浏览整个文件。最后一行的处理可能会有点奇怪，因为我们把光标放在那里，但没有在那里渲染。当我们在本章稍后加入状态栏时，这个问题将得到修复。如果你尝试向上滚动，你可能会注意到光标没有被正确定位。**这是因为状态中的<code>Position</code>不再指屏幕上光标的位置。它指的是光标在文本文件中的位置，但我们仍然将其传递给<code>cursor_position</code>。**为了在屏幕上定位光标，我们现在需要从文档中的位置减去偏移量。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -61,7 +61,10 @@</span> impl Editor &#123;<br>             println!(&quot;Goodbye.\r&quot;);<br>         &#125; else &#123;<br>             self.draw_rows();<br><span class="hljs-deletion">-            Terminal::cursor_position(&amp;self.cursor_position);</span><br><span class="hljs-addition">+            Terminal::cursor_position(&amp;Position &#123;</span><br><span class="hljs-addition">+                x: self.cursor_position.x.saturating_sub(self.offset.x),</span><br><span class="hljs-addition">+                y: self.cursor_position.y.saturating_sub(self.offset.y),</span><br><span class="hljs-addition">+            &#125;)</span><br>         &#125;<br>         Terminal::cursor_show();<br>         Terminal::flush()<br></code></pre></td></tr></table></figure><p>现在，让我们来解决水平滚动的问题。我们还没有允许光标滚动超过屏幕的右边界。我们将采取与向下滚动相同的对称处理方法来解决这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs src/editor.rs">@@ -90,9 +90,12 @@ impl Editor &#123;<br> <br>     fn move_cursor(&amp;mut self, key: Key) &#123;<br>         let Position &#123; mut x, mut y &#125; = self.cursor_position;<br>-        let size = self.terminal.size();<br>         let height = self.document.len();<br>-        let width = size.width.saturating_sub(1) as usize;<br>+        let width = if let Some(row) = self.document.row(y)&#123;<br>+            row.len()<br>+        &#125; else &#123;<br>+            0<br>+        &#125;;<br>         match key &#123;<br>             Key::Up =&gt; y = y.saturating_sub(1),<br>             Key::Down =&gt; &#123;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/row.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -18,4 +18,10 @@</span> impl Row &#123;<br>         let start = cmp::min(start, end);<br>         self.string.get(start..end).unwrap_or_default().to_string()<br>     &#125;<br><span class="hljs-addition">+    pub fn len(&amp;self) -&gt; usize &#123;</span><br><span class="hljs-addition">+        self.string.len()</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+    pub fn is_empty(&amp;self) -&gt; bool &#123;</span><br><span class="hljs-addition">+        self.string.is_empty()</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><p>我们所需要做的就是改变<code>move_cursor</code>使用的宽度。这样，水平滚动现在可以工作了。除此之外，当有了一个<code>len</code>函数时，实现<code>is_empty</code>函数是一个好习惯。</p><h2 id="处理光标在行末的情况">处理光标在行末的情况</h2><p>现在<code>cursor_position</code>指的是光标在文件内的位置，而不是它在屏幕上的位置。我们接下来几步的目标是限制<code>cursor_position</code>的值，只指向文件中的有效位置，除了一种情况外，即允许光标指向行尾之后的一个字符位置，或者文件末尾之后，这样用户就可以在行末或文件末轻松添加新字符。</p><p>我们已经能够防止用户将光标滚动得太远至右侧或下方。然而，用户仍然可以将光标移动到一行的末尾之后。他们可以通过将光标移到一长行的末尾，然后将其下移至更短的下一行来实现。这样<code>cursor_position.y</code>的值不会变，光标就会出现在它所在行的末尾的右侧。</p><p>现在我们修改一下<code>move_cursor()</code>，以纠正光标位置，如果光标最终超出了它所在行的末尾。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -91,7 +91,7 @@</span> impl Editor &#123;<br>     fn move_cursor(&amp;mut self, key: Key) &#123;<br>         let Position &#123; mut x, mut y &#125; = self.cursor_position;<br>         let height = self.document.len();<br><span class="hljs-deletion">-        let width = if let Some(row) = self.document.row(y)&#123;</span><br><span class="hljs-addition">+        let mut width = if let Some(row) = self.document.row(y) &#123;</span><br>             row.len()<br>         &#125; else &#123;<br>             0<br><span class="hljs-meta">@@ -115,6 +115,14 @@</span> impl Editor &#123;<br>             Key::PageDown =&gt; y = height,<br>             _ =&gt; (),<br>         &#125;<br><span class="hljs-addition">+        width = if let Some(row) = self.document.row(y) &#123;</span><br><span class="hljs-addition">+            row.len()</span><br><span class="hljs-addition">+        &#125; else &#123;</span><br><span class="hljs-addition">+            0</span><br><span class="hljs-addition">+        &#125;;</span><br><span class="hljs-addition">+        if x &gt; width &#123;</span><br><span class="hljs-addition">+            x = width;</span><br><span class="hljs-addition">+        &#125;</span><br>         self.cursor_position = Position &#123; x, y &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><p>我们需要再次设置<code>width</code>，因为在处理键盘输入时，<code>row</code>可能已经改变。然后，我们设置<code>x</code>的新值，确保<code>x</code>的值不超过当前行的宽度。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/c5a87dbb.html">https://zone.ivan-zhang.com.cn/p/c5a87dbb.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>TextEditor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144计算机网络Lab4: The Summit (TCP in Full)</title>
    <link href="/p/ac172a13.html"/>
    <url>/p/ac172a13.html</url>
    
    <content type="html"><![CDATA[<center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/15/652c095ff0876.png" alt="CS144TCPSocket" style="zoom:25%;" /><br>  <font color="DimGray" size="3">The arrangement of modules and dataflow in TCP implementation.</font></center><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/ac172a13.html">https://zone.ivan-zhang.com.cn/p/ac172a13.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust学习-制作一个文本编辑器: Raw Input And Output</title>
    <link href="/p/156e55dd.html"/>
    <url>/p/156e55dd.html</url>
    
    <content type="html"><![CDATA[<h2 id="使用键代替Byte">使用<code>键</code>代替<code>Byte</code></h2><p>在之前的步骤中，我们直接操作字节。然而，本着“不重复造轮子”的原则，我们可以使用各种库函数已经实现的方法。<code>termion</code>就已经提供了这个方法，它可以将单个字节组合成按键输入，并传递给我们：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, stdout&#125;;<br><span class="hljs-keyword">use</span> termion::raw::IntoRawMode;<br><span class="hljs-keyword">use</span> termion::event::Key;<br><span class="hljs-keyword">use</span> termion::input::TermRead;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">die</span>(e: std::io::Error)&#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">key</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">keys</span>()&#123;<br>        <span class="hljs-keyword">match</span> key&#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(key) =&gt; <span class="hljs-keyword">match</span> key&#123;<br>                Key::<span class="hljs-title function_ invoke__">Char</span>(c) =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> c.<span class="hljs-title function_ invoke__">is_control</span>() &#123;<br>                        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\r&quot;</span>, c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; (&#123;&#125;) \r&quot;</span>, c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>, c);<br>                    &#125;<br>                &#125;<br>                Key::<span class="hljs-title function_ invoke__">Ctrl</span>(<span class="hljs-string">&#x27;q&#x27;</span>) =&gt; <span class="hljs-keyword">break</span>,<br>                _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\r&quot;</span>, key),<br>            &#125;,<br>            <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-title function_ invoke__">die</span>(err),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们已经从处理原始字节转变为处理按键输入。利用<code>termion</code>，无需手动检测<code>Ctrl</code>是否被按下，因为它能自动处理所有按键事件。例如，<code>Key::Char(c)</code>代表单独的字符按键，而<code>Key::Ctrl(c)</code>和<code>Key::Alt(c)</code>分别代表与<code>Ctrl</code>或<code>Alt</code>键同时按下的字符。我们的焦点主要在字符输入上，尤其是像<code>Ctrl-Q</code>这样的组合键。</p><p>在使用<code>match</code>进行模式匹配时，会对按键进行区分处理：<code>Key::Char(c)</code>可以匹配任何字符，<code>Key::Ctrl('q')</code>则专门匹配<code>Ctrl-Q</code>组合。此前，我们将字节转换为字符以输出，而现在，<code>termion</code>提供了直接的字符输出，通过将字符转换为其对应的字节值来输出。</p><p>我们在<code>match</code>表达式中添加了一个默认分支<code>_</code>，用于捕获所有其他未特别处理的情况。<code>match</code>必须包含所有可能性，因此<code>_</code>作为一个通配符，确保了所有未预见的输入都得到了处理。若有输入既不是普通字符也不是特定组合键，就将其原样输出。</p><p>除此之外，为了简化代码，我们导入了<code>TermRead</code>特性，这样就可以使用<code>keys</code>方法来处理<code>stdin</code>输入，这比之前直接处理读取操作要简洁得多。</p><h2 id="将代码划分到多个源文件">将代码划分到多个源文件</h2><p>在<code>Rust</code>和许多其他编程语言中，<code>main</code>函数更多的是作为应用程序的启动入口，而不包含其他复杂逻辑。这是为了让代码更容易找到和维护。目前我们手头的代码层次较低，要理解整个代码，本质上它只是简单地将按下的键回显给用户，并在按下<code>Ctrl-Q</code>时退出。让我们通过创建多个文档来改进这段代码。</p><figure class="highlight rust"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Editor</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>在<code>Rust</code>中，<code>struct</code>是变量和函数的集合，它们组合在一起构成了一个有意义的实体，在我们的例子中就是<code>editor</code>。关键字<code>pub</code>表明这个结构体可以从<code>editor.rs</code>文件外部访问。我们想要在<code>main</code>函数中使用它，因此我们使用了<code>pub</code>。这正展示了将代码分离的另一个好处：<strong>我们可以确保某些函数只在内部调用，同时将其他函数暴露给系统的其他部分。</strong></p><p>现在，我们的编辑器需要一些功能。让我们为它提供一个<code>run()</code>函数：</p><figure class="highlight rust"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, stdout&#125;;<br><span class="hljs-keyword">use</span> termion::event::Key;<br><span class="hljs-keyword">use</span> termion::input::TermRead;<br><span class="hljs-keyword">use</span> termion::raw::IntoRawMode;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Editor</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">key</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">keys</span>()&#123;<br>            <span class="hljs-keyword">match</span> key&#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(key) =&gt; <span class="hljs-keyword">match</span> key&#123;<br>                    Key::<span class="hljs-title function_ invoke__">Char</span>(c) =&gt; &#123;<br>                        <span class="hljs-keyword">if</span> c.<span class="hljs-title function_ invoke__">is_control</span>() &#123;<br>                            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\r&quot;</span>, c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; (&#123;&#125;) \r&quot;</span>, c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>, c);<br>                        &#125;<br>                    &#125;<br>                    Key::<span class="hljs-title function_ invoke__">Ctrl</span>(<span class="hljs-string">&#x27;q&#x27;</span>) =&gt; <span class="hljs-keyword">break</span>,<br>                    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\r&quot;</span>, key),<br>                &#125;,<br>                <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-title function_ invoke__">die</span>(err),<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">die</span>(e: std::io::Error)&#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>run</code>函数接受一个名为<code>&amp;self</code>的参数，它将包含对被调用结构体的引用（<code>&amp;</code>表明我们在处理一个引用）。这相当于在<code>impl</code>代码块外部有一个接受<code>&amp;Editor</code>作为第一个参数的函数。</p><p>让我们通过重构我们的<code>main.rs</code>：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> editor;<br><br><span class="hljs-keyword">use</span> editor::Editor;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">editor</span> = Editor &#123;&#125;;<br>    editor.<span class="hljs-title function_ invoke__">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>main</code>中，我们创建了一个<code>Editor</code>的新实例，并在其上调用<code>run()</code>方法。现在，让我们改进<code>main</code>中剩下的几行代码。结构体允许我们将变量组合在一起，但目前我们的结构体是空的——它不包含任何变量。一旦我们开始往结构体中添加内容，我们就需要在创建新的<code>Editor</code>实例时立即设置所有字段。这意味着每当在<code>Editor</code>中添加新条目时，我们都必须回到<code>main</code>函数中，并修改<code>let editor = editor::Editor&#123;&#125;;</code>这行代码来设置新的字段值。这样做并不理想，所以让我们重构一下这部分代码。</p><figure class="highlight rust"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*codes*/</span><br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-comment">/*codes*/</span><br>    <br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">default</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Editor&#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*codes*/</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> editor;<br><br><span class="hljs-keyword">use</span> editor::Editor;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">editor</span> = Editor::<span class="hljs-title function_ invoke__">default</span>();<br>    editor.<span class="hljs-title function_ invoke__">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在创建了一个名为<code>default</code>的新函数，用于构建一个<code>Editor</code>实例。值得注意的是，<code>default</code>函数的最后一行没有包含<code>return</code>关键字，也没有以分号<code>;</code>结尾。<strong><code>Rust</code>会将函数中最后一行的结果作为其输出，并且通过省略分号。</strong></p><p>与<code>run</code>不同，<code>default</code>函数不是在已有的<code>Editor</code>实例上调用的，这一点从函数签名中缺少<code>&amp;self</code>参数可以看出。<code>default</code>是一个静态方法，通过使用<code>::</code>调用。</p><h2 id="分离读取和处理">分离读取和处理</h2><p>让我们创建一个用于读取按键的函数，以及另一个函数用于将按键映射到编辑器操作：</p><figure class="highlight rust"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*codes*/</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Editor</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Err</span>(error) = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">process_keypress</span>() &#123;<br>                <span class="hljs-title function_ invoke__">die</span>(error)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*codes*/</span><br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_keypress</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), std::io::Error&gt;&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pressed_key</span> = <span class="hljs-title function_ invoke__">read_key</span>()?;<br>        <span class="hljs-keyword">match</span> pressed_key &#123;<br>            Key::<span class="hljs-title function_ invoke__">Ctrl</span>(<span class="hljs-string">&#x27;q&#x27;</span>) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Program end&quot;</span>),<br>            _ =&gt; ()<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_key</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Key, std::io::Error&gt; &#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(key) = io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">keys</span>().<span class="hljs-title function_ invoke__">next</span>() &#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*codes*/</span><br></code></pre></td></tr></table></figure><p>我们现在在<code>run</code>函数中添加了一个循环。循环会一直重复执行，直到被明确地中断。在这个循环内，我们使用了<code>Rust</code>的另一个特性：<code>if let</code>。这是<code>match</code>的简写形式，用于只处理一个情况而忽略所有其他可能的情况。你可以查看<code>process_keypress()</code>函数的代码，了解一个可以完全用<code>if let</code>替代的<code>match</code>情况。</p><p>在<code>run</code>中，执行<code>self.process_keypress()</code>并检查结果是否匹配<code>Err</code>。如果是，就将错误解包并传递给<code>die</code>函数，如果不是，则不做任何事情。</p><p>我们可以通过查看<code>process_keypress</code>函数的声明来更清晰地了解这一点：</p><figure class="highlight rust"><figcaption><span>process_keypress()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_keypress</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), std::io::Error&gt;<br></code></pre></td></tr></table></figure><p><code>-&gt;</code>后面的部分表明：这个函数返回一个<code>Result</code>类型。<code>&lt;&gt;</code>里的内容告诉我们<code>Ok</code>和<code>Err</code>分别包含什么内容：<code>Ok</code>会包裹一个<code>()</code>，意味着<strong>无内容</strong>，而<code>Err</code>会包裹一个<code>std::io::Error</code>。<code>process_keypress()</code>函数等待按键输入，然后处理它。随后，它会将各种<code>Ctrl</code>组合键和其他特殊键映射到不同的编辑器功能，将任何字母数字和其他可打印键的字符插入到正在编辑的文本中。这就是为什么在这里使用<code>match</code>而不是<code>if let</code>。</p><p>这个函数的最后一行可能有点难以理解。我们不希望函数返回任何内容，那么为什么要用<code>ok(())</code>呢？这是因为：调用<code>read_key</code>时可能会出现错误，我们希望将这个错误传递给调用函数。由于<code>Rust</code>没有<code>try..catch</code>，我们需要返回一个表示<strong>一切正常</strong>的东西，即使我们实际上没有返回任何值。这正是<code>ok(())</code>所做的：它表示：<strong>一切正常，没有返回任何内容</strong>。</p><p>但如果出现了错误怎么办呢？从<code>read_key</code>的声明中我们可以看出，错误可能会传递给我们。如果真的如此，就没有继续执行的必要了，我们希望错误也被返回。但如果没有发生错误，我们希望继续执行，并使用未包装的值。<code>let pressed_key = read_key()?</code>中的<code>?</code>的就是为此服务的：<strong>如果有错误，就返回它，如果没有，就解包值并继续</strong>。</p><p><code>read_key</code>函数也包含一个循环，在按下有效键后循环会结束。<code>io::stdin().lock().keys().next()</code>返回的值与上文讨论的<code>Result</code>很相似——这是一个叫做<code>Option</code>的类型。目前你只需要知道<code>Option</code>可以是<code>None</code>——在这种情况下意味着没有按键被按下，循环会继续；或者它可以包裹一个<code>Some</code>值，在这种情况下我们返回从<code>read_key</code>中解包的值。</p><p>更复杂的是<code>io::stdin().lock().keys().next()</code>的实际返回值是一个包裹在<code>Result</code>里的<code>Key</code>，而这个<code>Result</code>又被包裹在一个<code>Option</code>里。我们在<code>read_key()</code>中解包<code>Option</code>，然后在<code>process_keypress()</code>中处理<code>Result</code>。</p><p>这就是错误如何传递到<code>run</code>中并最终由<code>die</code>处理的方式。说到<code>die</code>，我们的代码中出现了一个新的问题：由于我们还不知道如何从程序内部退出，所以当用户按下<code>Ctrl-Q</code>时，我们现在会调用<code>painc</code>。</p><p>我们可以调用一个适当的方法来结束程序（如<code>std::process::exit</code>），但正如我们不希望程序在代码深处随机崩溃一样，我们也不希望它在代码的深层部分退出。我们通过向<code>Editor</code>结构体添加一个元素来解决这个问题：<strong>一个布尔值</strong>，用于指示用户是否想要退出：</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-pub struct Editor &#123;&#125;</span><br><span class="hljs-addition">+pub struct Editor &#123;</span><br><span class="hljs-addition">+    should_quit: bool,</span><br><span class="hljs-addition">+&#125;</span><br> <br> impl Editor &#123;<br>     pub fn run(&amp;self) &#123;<br>         let _stdout = stdout().into_raw_mode().unwrap();<br>     <br>         loop &#123;<br>             if let Err(error) = self.process_keypress() &#123;<br>                 die(error)<br>             &#125;<br>         &#125;<br>     &#125;<br> <br>     pub fn default() -&gt; Self &#123;<br><span class="hljs-deletion">-        Self &#123;&#125;</span><br><span class="hljs-addition">+        Self &#123; should_quit: false &#125;</span><br>     &#125;<br></code></pre></td></tr></table></figure><p>我们需要在<code>default</code>函数中立即初始化<code>should_quit</code>，否则我们的代码无法编译。现在就设置这个布尔值，并在它为<code>true</code>时退出程序。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs diff"> impl Editor &#123;<br><span class="hljs-deletion">-    pub fn run(&amp;self) &#123;</span><br><span class="hljs-addition">+    pub fn run(&amp;mut self) &#123;</span><br>         let _stdout = stdout().into_raw_mode().unwrap();<br>     <br>         loop &#123;<br>             if let Err(error) = self.process_keypress() &#123;<br>                 die(error)<br>             &#125;<br><span class="hljs-addition">+            if self.should_quit &#123;</span><br><span class="hljs-addition">+                break;</span><br><span class="hljs-addition">+            &#125;</span><br>         &#125;<br>     &#125;<br> <br>     pub fn default() -&gt; Self &#123;<br>         Self &#123; should_quit: false &#125;<br>     &#125;<br> <br><span class="hljs-deletion">-    fn process_keypress(&amp;self) -&gt; Result&lt;(), std::io::Error&gt;&#123;</span><br><span class="hljs-addition">+    fn process_keypress(&amp;mut self) -&gt; Result&lt;(), std::io::Error&gt;&#123;</span><br>         let pressed_key = read_key()?;<br>         match pressed_key &#123;<br><span class="hljs-deletion">-            Key::Ctrl(&#x27;q&#x27;) =&gt; panic!(&quot;Program end&quot;),</span><br><span class="hljs-addition">+            Key::Ctrl(&#x27;q&#x27;) =&gt; self.should_quit = true,</span><br>             _ =&gt; ()<br>         &#125;<br>         Ok(())<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -5,6 +5,5 @@</span> mod editor;<br> use editor::Editor;<br> <br> fn main() &#123;<br><span class="hljs-deletion">-    let editor = Editor::default();</span><br><span class="hljs-deletion">-    editor.run();</span><br><span class="hljs-addition">+    Editor::default().run()</span><br> &#125;<br></code></pre></td></tr></table></figure><p>我们现在让<code>should_quit</code>为<code>true</code>时用<code>break</code>来终止循环，并在<code>run</code>函数中检查这一点。这使得程序退出的逻辑比之前清晰得多。</p><p>此外，我们还做了一些调整。在<code>process_keypress()</code>函数中，我们对<code>self</code>进行了修改，因此需要将参数从<code>&amp;self</code>改为<code>&amp;mut self</code>，以便能够修改引用。<code>Rust</code>对可变引用有严格的规则。</p><p>同样地，由于<code>run</code>函数内部需要调用<code>process_keypress()</code>，我们也调整了它的函数声明。</p><p>最后，在<code>main</code>函数中，<code>let editor = ...</code>表示<code>editor</code>是不可变的，我们不能在其上执行可能会修改它的<code>run</code>。为此我们将其改为<code>let mut editor</code>。现在我们不再需要<code>editor</code>变量，直接在<code>default()</code>的返回值上调用<code>run()</code>。</p><h2 id="清空屏幕">清空屏幕</h2><p>在之前，用户每次按键时，都会打印在屏幕上。现在让我们清空屏幕。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,4 +1,4 @@</span><br><span class="hljs-deletion">-use std::io::&#123;self, stdout&#125;;</span><br><span class="hljs-addition">+use std::io::&#123;self, stdout, Write&#125;;</span><br> use termion::event::Key;<br> use termion::input::TermRead;<br> use termion::raw::IntoRawMode;<br><span class="hljs-meta">@@ -10,14 +10,17 @@</span> pub struct Editor &#123;<br> impl Editor &#123;<br>     pub fn run(&amp;mut self) &#123;<br>         let _stdout = stdout().into_raw_mode().unwrap();<br>    <br>         loop &#123;<br><span class="hljs-deletion">-            if let Err(error) = self.process_keypress() &#123;</span><br>             if let Err(error) = self.refresh_screen() &#123;<br>                 die(error)<br><span class="hljs-addition">+            &#125;</span><br>             if self.should_quit &#123;<br>                 break;<br>             &#125;<br><span class="hljs-addition">+            if let Err(error) = self.process_keypress() &#123;</span><br><span class="hljs-addition">+                die(error)</span><br><span class="hljs-addition">+            &#125;</span><br>         &#125;<br>     &#125;<br> <br><span class="hljs-meta">@@ -25,11 +28,16 @@</span> impl Editor &#123;<br>         Self &#123; should_quit: false &#125;<br>     &#125;<br> <br><span class="hljs-addition">+    fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;</span><br><span class="hljs-addition">+        print!(&quot;\x1b[2J&quot;);</span><br><span class="hljs-addition">+        io::stdout().flush()</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+</span><br>     fn process_keypress(&amp;mut self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br>         let pressed_key = read_key()?;<br>         match pressed_key &#123;<br>             Key::Ctrl(&#x27;q&#x27;) =&gt; self.should_quit = true,<br>             _ =&gt; (),<br>         &#125;<br>         Ok(())<br>     &#125;<br></code></pre></td></tr></table></figure><p>我们新增了一个名为<code>refresh_screen</code>的函数，在退出程序前调用。我们将<code>process_keypress()</code>移至较低的位置，这意味着**即使用户退出程序，我们仍会在最终退出前刷新一次屏幕。**这样做是为了后续能打印退出消息。</p><p>为了清屏，我们使用<code>print</code>函数向终端写入4个字节。第一个字节是<code>\x1b</code>，即转义字符，十进制下是27。其余三个字节是<code>[2J</code>。</p><p>我们正在向终端写入一个转义序列。转义序列总是以转义字符（如<code>Esc</code>键产生的27）开始，后跟一个<code>[</code>字符。转义序列指示终端执行各种文本格式化任务，如改变文本颜色、移动光标或清除屏幕的部分内容。</p><p>我们使用<code>J</code>命令<code>(Erase In Display)</code>来清除屏幕。转义序列命令通常会带参数，参数位于命令之前。在这里参数是<code>2</code>，表示清除整个屏幕。<code>\x1b[1J</code>会清除光标处到屏幕顶部的内容，而<code>\x1b[0J</code>会清除光标处到屏幕末尾的内容。<code>J</code>命令默认的参数就是<code>0</code>，所以只写<code>\x1b[J</code>也能从光标处清屏到末尾。</p><p>向终端写入内容后，我们会调用<code>flush()</code>，它会强制<code>stdout</code>输出它所缓存的所有内容（有时它可能会缓存某些值而不是直接打印出来）。我们也返回了<code>flush()</code>的结果，与前面类似，要么是<code>Ok</code>表示没有值（即一切正常），要么是<code>Err</code>包装了一个错误（即刷新失败）。这一点很重要：如果我们在<code>flush()</code>之后添加了;`，我们就不会返回它的结果。</p><p>使用<code>termion</code>库让我们无需直接向终端写入转义序列，因此我们可以按照如下方式修改代码：</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -29,7 +29,7 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br><span class="hljs-deletion">-        print!(&quot;\x1b[2J&quot;);</span><br><span class="hljs-addition">+        print!(&quot;&#123;&#125;&quot;,termion::clear::All);</span><br>         io::stdout().flush()<br>     &#125;<br></code></pre></td></tr></table></figure><p>现在，由于我们现在每次运行程序都会清屏，我们可能会错过编译器提供的有价值的提示。可以通过单独运行<code>cargo build</code>来查看这些警告。但请记住，<strong>如果你的代码没有变化，<code>Rust</code>不会重新编译你的代码</strong>，所以在执行<code>cargo run</code>之后立即运行<code>cargo build</code>并不会显示相同的警告。你可以先运行<code>cargo clean</code>然后再运行<code>cargo build</code>来重新编译整个项目，并查看所有的警告。</p><h2 id="光标重定位">光标重定位</h2><p>在前面的代码中，虽然执行了清屏的操作，但是光标依然会停留在以前的位置。我们需要将光标重新定位到左上角，以便准备从上到下绘制编辑器界面。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -29,7 +29,7 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br><span class="hljs-deletion">-        print!(&quot;&#123;&#125;&quot;,termion::clear::All);</span><br><span class="hljs-addition">+        print!(&quot;&#123;&#125;&#123;&#125;&quot;, termion::clear::All, termion::cursor::Goto(1, 1));</span><br>         io::stdout().flush()<br>     &#125;<br></code></pre></td></tr></table></figure><p><code>termion</code>库中的转义序列<code>termion::cursor::Goto</code>使用<a href="https://vt100.net/docs/vt100-ug/chapter3.html#CUP"><code>H</code>命令</a>来定位光标，它实际上需要两个参数：行号和列号，来确定光标的新位置。因此，如果你的终端大小是<code>80x24</code>，并且你想要将光标置于屏幕中心，你可以使用<code>\x1b[12;40H</code>命令（多个参数之间用分号<code>;</code>分隔）。由于行和列的编号是从<code>1</code>开始的，而不是<code>0</code>，所以<code>termion</code>方法也是基于<code>1</code>的索引。</p><h2 id="退出时清屏">退出时清屏</h2><p>当我们的程序崩溃时，就清屏并重新定位光标。如果在渲染屏幕的过程中发生错误，我们不希望屏幕上留下一堆乱码，也不希望错误信息就在光标当前的位置被打印出来。此外，如果用户决定退出，我们也会借此机会打印一条告别信息。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -30,6 +30,9 @@</span> impl Editor &#123;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br>         print!(&quot;&#123;&#125;&#123;&#125;&quot;, termion::clear::All, termion::cursor::Goto(1, 1));<br><span class="hljs-addition">+        if self.should_quit &#123;</span><br><span class="hljs-addition">+            println!(&quot;Goodbye.\r&quot;);</span><br><span class="hljs-addition">+        &#125;</span><br>         io::stdout().flush()<br>     &#125;<br> <br><span class="hljs-meta">@@ -52,5 +55,6 @@</span> fn read_key() -&gt; Result&lt;Key, std::io::Error&gt; &#123;<br> &#125;<br> <br> fn die(e: std::io::Error) &#123;<br><span class="hljs-addition">+    print!(&quot;&#123;&#125;&quot;, termion::clear::All);</span><br>     panic!(&quot;&#123;&#125;&quot;, e);<br> &#125;<br></code></pre></td></tr></table></figure><p>##<code>~</code></p><p>是时候开始绘制界面了。让我们在屏幕的左侧绘制一列波浪号<code>~</code>，就像<code>vim</code>编辑器那样。在我们的文本编辑器中，我们将在被编辑文件内容结束后的每一行的开头绘制一个波浪号。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -32,6 +32,9 @@</span> impl Editor &#123;<br>         print!(&quot;&#123;&#125;&#123;&#125;&quot;, termion::clear::All, termion::cursor::Goto(1, 1));<br>         if self.should_quit &#123;<br>             println!(&quot;Goodbye.\r&quot;);<br><span class="hljs-addition">+        &#125; else &#123;</span><br><span class="hljs-addition">+            self.draw_rows();</span><br><span class="hljs-addition">+            print!(&quot;&#123;&#125;&quot;, termion::cursor::Goto(1, 1));</span><br>         &#125;<br>         io::stdout().flush()<br>     &#125;<br><span class="hljs-meta">@@ -44,6 +47,12 @@</span> impl Editor &#123;<br>         &#125;<br>         Ok(())<br>     &#125;<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    fn draw_rows(&amp;self) &#123;</span><br><span class="hljs-addition">+        for _ in 1..24 &#123;</span><br><span class="hljs-addition">+            println!(&quot;~\r&quot;);</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br> <br> fn read_key() -&gt; Result&lt;Key, std::io::Error&gt; &#123;<br></code></pre></td></tr></table></figure><p><code>draw_rows()</code>函数负责绘制正在编辑的文本缓冲区的每一行。现在，它在每一行都绘制一个波浪符号，这表示**该行不是文件的一部分，也不会包含任何文本。**我们还不知道终端的大小，因此也不知道要绘制多少行。目前我们只绘制<code>24</code>行。在<code>for _ in</code>循环中，<code>_</code>表示我们不关心任何值，只是想重复执行某个操作多次。绘制完毕后，我们将光标重新定位到左上角。</p><h2 id="窗口大小">窗口大小</h2><p>我们接下来的目标是获取终端的尺寸，这样我们就知道在<code>draw_rows()</code>中需要绘制多少行。<code>termion</code>为我们提供了一个获取屏幕尺寸的方法，我们将使用这个方法在代表终端的新数据结构中。我们会将其放在一个名为<code>terminal.rs</code>的新文件中。</p><figure class="highlight diff"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,9 +1,11 @@</span><br> #![allow(non_snake_case)]<br> <br> mod editor;<br><span class="hljs-addition">+mod terminal;</span><br> <br> use editor::Editor;<br><span class="hljs-addition">+pub use terminal::Terminal;</span><br> <br> fn main() &#123;<br>     Editor::default().run()<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,3 +1,4 @@</span><br><span class="hljs-addition">+use crate::Terminal;</span><br> use std::io::&#123;self, stdout, Write&#125;;<br> use termion::event::Key;<br> use termion::input::TermRead;<br><span class="hljs-meta">@@ -5,6 +6,7 @@</span> use termion::raw::IntoRawMode;<br> <br> pub struct Editor &#123;<br>     should_quit: bool,<br><span class="hljs-addition">+    terminal: Terminal,</span><br> &#125;<br> <br> impl Editor &#123;<br><span class="hljs-meta">@@ -25,7 +27,10 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     pub fn default() -&gt; Self &#123;<br><span class="hljs-deletion">-        Self &#123; should_quit: false &#125;</span><br><span class="hljs-addition">+        Self &#123;</span><br><span class="hljs-addition">+            should_quit: false,</span><br><span class="hljs-addition">+            terminal: Terminal::default().expect(&quot;Failed to initialize terminal&quot;),</span><br><span class="hljs-addition">+        &#125;</span><br>     &#125;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br><span class="hljs-meta">@@ -49,7 +54,7 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn draw_rows(&amp;self) &#123;<br><span class="hljs-deletion">-        for _ in 1..24 &#123;</span><br><span class="hljs-addition">+        for _ in 0..self.terminal.size().height &#123;</span><br>             println!(&quot;~\r&quot;);<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/terminal.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -0,0 +1,24 @@</span><br><span class="hljs-addition">+pub struct Size &#123;</span><br><span class="hljs-addition">+    pub width: u16,</span><br><span class="hljs-addition">+    pub height: u16,</span><br><span class="hljs-addition">+&#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+pub struct Terminal &#123;</span><br><span class="hljs-addition">+    size: Size,</span><br><span class="hljs-addition">+&#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+impl Terminal &#123;</span><br><span class="hljs-addition">+    pub fn default() -&gt; Result&lt;Self, std::io::Error&gt; &#123;</span><br><span class="hljs-addition">+        let size = termion::terminal_size()?;</span><br><span class="hljs-addition">+        Ok(Self &#123;</span><br><span class="hljs-addition">+            size: Size &#123;</span><br><span class="hljs-addition">+                width: size.0,</span><br><span class="hljs-addition">+                height: size.1,</span><br><span class="hljs-addition">+            &#125;,</span><br><span class="hljs-addition">+        &#125;)</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn size(&amp;self) -&gt; &amp;Size &#123;</span><br><span class="hljs-addition">+        &amp;self.size</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+&#125;</span><br></code></pre></td></tr></table></figure><p>在<code>terminal.rs</code>中，我们定义了<code>Terminal</code>和一个辅助结构体<code>Size</code>。在<code>default</code>中，我们获取了<code>termion</code>的<code>terminal_size</code>，并将其转换为<code>Size</code>，然后返回<code>Terminal</code>的新实例。为了处理潜在的错误，我们将其包装在<code>Ok</code>中。我们也不想让外部调用者修改终端尺寸。因此，我们没有用<code>pub</code>标记<code>size</code>为公开的。相反，我们添加了一个名为<code>size</code>的方法，它返回对内部<code>size</code>的只读引用。<code>Size.width</code>和<code>height</code>都是<code>u16s</code>，是一个无符号的<code>16</code>位整数，大约在<code>65,000</code>左右结束。这对于终端来说很够用了。</p><p>现在对于新的结构体，让我们研究一下它是如何从编辑器中被引用的。首先，我们在<code>main.rs</code>中引入我们的新结构体，并在<code>Terminal</code>结构体前添加了<code>pub</code>使其公开。这样做有什么作用呢？–在<code>editor.rs</code>中，我们现在可以使用<code>use crate::Terminal</code>来导入终端。如果没有在<code>main.rs</code>中使用<code>pub use</code>语句，我们就不能这样做，相反我们需要使用<code>use crate::terminal::Terminal</code>。实质上，我们在顶层导出了<code>Terminal</code>结构体，并通过<code>crate::Terminal</code>使其可达。</p><p>在我们的编辑器结构体中，我们在初始化<code>default()</code>时添加了对我们终端的引用。注意<code>Terminal::default</code>返回一个<code>Terminal</code>实例或一个错误。我们用<code>expect</code>解包<code>Terminal</code>，如果我们有一个值，我们返回它。如果我们没有一个值，我们就会带着传递给<code>expect</code>的文本引发<code>painc</code>。在这里我们不需要<code>die</code>，因为<code>die</code>主要在我们重复绘制屏幕时才有用。</p><p>现在我们把与<code>Terminal</code>相关的代码移到新文件中：</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,8 +1,5 @@</span><br> use crate::Terminal;<br><span class="hljs-deletion">-use std::io::&#123;self, stdout, Write&#125;;</span><br> use termion::event::Key;<br><span class="hljs-deletion">-use termion::input::TermRead;</span><br><span class="hljs-deletion">-use termion::raw::IntoRawMode;</span><br> <br> pub struct Editor &#123;<br>     should_quit: bool,<br><span class="hljs-meta">@@ -11,8 +8,6 @@</span> pub struct Editor &#123;<br> <br> impl Editor &#123;<br>     pub fn run(&amp;mut self) &#123;<br><span class="hljs-deletion">-        let _stdout = stdout().into_raw_mode().unwrap();</span><br><span class="hljs-deletion">-</span><br>         loop &#123;<br>             if let Err(error) = self.refresh_screen() &#123;<br>                 die(error)<br><span class="hljs-meta">@@ -34,18 +29,19 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br><span class="hljs-deletion">-        print!(&quot;&#123;&#125;&#123;&#125;&quot;, termion::clear::All, termion::cursor::Goto(1, 1));</span><br><span class="hljs-addition">+        Terminal::clear_screen();</span><br><span class="hljs-addition">+        Terminal::cursor_position(0, 0);</span><br>         if self.should_quit &#123;<br>             println!(&quot;Goodbye.\r&quot;);<br>         &#125; else &#123;<br>             self.draw_rows();<br><span class="hljs-deletion">-            print!(&quot;&#123;&#125;&quot;, termion::cursor::Goto(1, 1));</span><br><span class="hljs-addition">+            Terminal::cursor_position(0, 0);</span><br>         &#125;<br><span class="hljs-deletion">-        io::stdout().flush()</span><br><span class="hljs-addition">+        Terminal::flush()</span><br>     &#125;<br> <br>     fn process_keypress(&amp;mut self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br><span class="hljs-deletion">-        let pressed_key = read_key()?;</span><br><span class="hljs-addition">+        let pressed_key = Terminal::read_key()?;</span><br>         match pressed_key &#123;<br>             Key::Ctrl(&#x27;q&#x27;) =&gt; self.should_quit = true,<br>             _ =&gt; (),<br><span class="hljs-meta">@@ -60,15 +56,7 @@</span> impl Editor &#123;<br>     &#125;<br> &#125;<br> <br><span class="hljs-deletion">-fn read_key() -&gt; Result&lt;Key, std::io::Error&gt; &#123;</span><br><span class="hljs-deletion">-    loop &#123;</span><br><span class="hljs-deletion">-        if let Some(key) = io::stdin().lock().keys().next() &#123;</span><br><span class="hljs-deletion">-            return key;</span><br><span class="hljs-deletion">-        &#125;</span><br><span class="hljs-deletion">-    &#125;</span><br><span class="hljs-deletion">-&#125;</span><br><span class="hljs-deletion">-</span><br> fn die(e: std::io::Error) &#123;<br><span class="hljs-deletion">-    print!(&quot;&#123;&#125;&quot;, termion::clear::All);</span><br><span class="hljs-addition">+    Terminal::clear_screen();</span><br>     panic!(&quot;&#123;&#125;&quot;, e);<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/terminal.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,3 +1,8 @@</span><br><span class="hljs-addition">+use std::io::&#123;self, stdout, Write&#125;;</span><br><span class="hljs-addition">+use termion::event::Key;</span><br><span class="hljs-addition">+use termion::input::TermRead;</span><br><span class="hljs-addition">+use termion::raw::&#123;IntoRawMode, RawTerminal&#125;;</span><br><span class="hljs-addition">+</span><br> pub struct Size &#123;<br>     pub width: u16,<br>     pub height: u16,<br><span class="hljs-meta">@@ -5,6 +10,7 @@</span> pub struct Size &#123;<br> <br> pub struct Terminal &#123;<br>     size: Size,<br><span class="hljs-addition">+    _stdout: RawTerminal&lt;std::io::Stdout&gt;,</span><br> &#125;<br> <br> impl Terminal &#123;<br><span class="hljs-meta">@@ -15,10 +21,33 @@</span> impl Terminal &#123;<br>                 width: size.0,<br>                 height: size.1,<br>             &#125;,<br><span class="hljs-addition">+            _stdout: stdout().into_raw_mode()?,</span><br>         &#125;)<br>     &#125;<br> <br>     pub fn size(&amp;self) -&gt; &amp;Size &#123;<br>         &amp;self.size<br>     &#125;<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn clear_screen() &#123;</span><br><span class="hljs-addition">+        print!(&quot;&#123;&#125;&quot;, termion::clear::All);</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn cursor_position(x: u16, y: u16) &#123;</span><br><span class="hljs-addition">+        let x = x.saturating_add(1);</span><br><span class="hljs-addition">+        let y = y.saturating_add(1);</span><br><span class="hljs-addition">+        print!(&quot;&#123;&#125;&quot;, termion::cursor::Goto(x, y));</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn flush() -&gt; Result&lt;(), std::io::Error&gt; &#123;</span><br><span class="hljs-addition">+        io::stdout().flush()</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn read_key() -&gt; Result&lt;Key, std::io::Error&gt; &#123;</span><br><span class="hljs-addition">+        loop &#123;</span><br><span class="hljs-addition">+            if let Some(key) = io::stdin().lock().keys().next() &#123;</span><br><span class="hljs-addition">+                return key;</span><br><span class="hljs-addition">+            &#125;</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><p>我们将所有低级终端相关的内容移到了<code>Terminal</code>中，把高级内容留在了<code>editor.rs</code>。</p><ul><li>不需要在编辑器的原始模式中跟踪<code>stdout</code>了。这现在由<code>Terminal</code>内部处理——只要<code>Terminal</code>结构体存在，<code>_stdout</code>就会存在。</li><li>通过使<code>Terminal::cursor_position</code>基于<code>0</code>隐藏了终端是基于<code>1</code>的事实。</li><li>防止<code>u16</code>类型的<code>cursor_position</code>发生溢出。</li></ul><p><strong>关于溢出</strong>，我们的类型有它们可以容纳的最大大小。如前所述，对于<code>u16</code>，这个限制大约在<code>65,000</code>。那么如果你在最大值上<code>+1</code>会发生什么？它会变成可能的最小值，也就是对于无符号类型来说是<code>0</code>！这被称为<strong>溢出</strong>。在<code>Rust</code>中处理溢出的正常方式如下：在调试模式（默认情况下我们使用的模式）中，程序会崩溃。这是我们所期望的：**编译器不应该试图让你的程序保持运行，而应该明显地显示出问题。**在生产模式下，会发生溢出，这也是我们所期望的，**因为我们不希望应用程序在生产中意外崩溃，它可以继续使用溢出值。**在我们的程序中我们使用<code>saturating_add</code>尝试<code>+1</code>，否则就返回最大值。</p><h2 id="最后一行">最后一行</h2><p>你可能注意到屏幕的最后一行似乎没有波浪符号。这是代码中的一个小错误。当我们打印最后一个波浪符号时，我们接着打印了一个<code>&quot;\r\n&quot;</code>，就像打印其他任何一行一样，但这会导致终端滚动以腾出空间给一个新的空白行。由于我们稍后想在底部有一个状态栏，现在让我们先改变我们绘制行的范围。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -50,7 +50,7 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn draw_rows(&amp;self) &#123;<br><span class="hljs-deletion">-        for _ in 0..self.terminal.size().height &#123;</span><br><span class="hljs-addition">+        for _ in 0..self.terminal.size().height - 1 &#123;</span><br>             println!(&quot;~\r&quot;);<br></code></pre></td></tr></table></figure><h2 id="绘制时隐藏光标">绘制时隐藏光标</h2><p>还有一个问题：光标可能会在终端绘制到屏幕上的那一刻短暂地显示在屏幕中间的某个地方。为了确保这种情况不会发生，我们在刷新屏幕之前隐藏光标，并在刷新结束后立即显示它。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -29,6 +29,7 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br><span class="hljs-addition">+        Terminal::cursor_hide();</span><br>         Terminal::clear_screen();<br>         Terminal::cursor_position(0, 0);<br>         if self.should_quit &#123;<br><span class="hljs-meta">@@ -37,6 +38,7 @@</span> impl Editor &#123;<br>             self.draw_rows();<br>             Terminal::cursor_position(0, 0);<br>         &#125;<br><span class="hljs-addition">+        Terminal::cursor_show();</span><br>         Terminal::flush()<br>     &#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/terminal.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -50,4 +50,12 @@</span> impl Terminal &#123;<br>             &#125;<br>         &#125;<br>     &#125;<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn cursor_hide() &#123;</span><br><span class="hljs-addition">+        print!(&quot;&#123;&#125;&quot;, termion::cursor::Hide);</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn cursor_show() &#123;</span><br><span class="hljs-addition">+        print!(&quot;&#123;&#125;&quot;, termion::cursor::Show);</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><h2 id="逐行清除">逐行清除</h2><p>与其在每次刷新前清除整个屏幕，不如在我们重绘每一行时清除该行，这似乎更为理想。让我们用<code>\x1b[K</code>序列（在我们绘制的每一行开头）替换<code>termion::clear::All</code>（清除整个屏幕）转义序列，并结合使用<code>termion::clear::CurrentLine</code>进行绘制。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -33,6 +33,7 @@</span> impl Editor &#123;<br>         Terminal::clear_screen();<br>         Terminal::cursor_position(0, 0);<br>         if self.should_quit &#123;<br><span class="hljs-addition">+            Terminal::clear_screen();</span><br>             println!(&quot;Goodbye.\r&quot;);<br>         &#125; else &#123;<br>             self.draw_rows();<br><span class="hljs-meta">@@ -53,6 +54,7 @@</span> impl Editor &#123;<br> <br>     fn draw_rows(&amp;self) &#123;<br>         for _ in 0..self.terminal.size().height - 1 &#123;<br><span class="hljs-addition">+            Terminal::clear_current_line();</span><br>             println!(&quot;~\r&quot;);<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/terminal.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -58,4 +58,8 @@</span> impl Terminal &#123;<br>     pub fn cursor_show() &#123;<br>         print!(&quot;&#123;&#125;&quot;, termion::cursor::Show);<br>     &#125;<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    pub fn clear_current_line() &#123;</span><br><span class="hljs-addition">+        print!(&quot;&#123;&#125;&quot;, termion::clear::CurrentLine);</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，在显示告别信息之前也会先清除屏幕，以避免在程序最终结束前，告别信息覆盖在其他行上方。</p><h2 id="欢迎信息">欢迎信息</h2><p>是时候显示一个欢迎信息了。在程序启动时，让在屏幕下方三分之一的位置显示我们编辑器的名称和版本号。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,6 +1,7 @@</span><br> use crate::Terminal;<br> use termion::event::Key;<br> <br><span class="hljs-addition">+const VERSION: &amp;str = env!(&quot;CARGO_PKG_VERSION&quot;);</span><br> pub struct Editor &#123;<br>     should_quit: bool,<br>     terminal: Terminal,<br><span class="hljs-meta">@@ -53,9 +54,14 @@</span> impl Editor &#123;<br>     &#125;<br> <br>     fn draw_rows(&amp;self) &#123;<br><span class="hljs-deletion">-        for _ in 0..self.terminal.size().height - 1 &#123;</span><br><span class="hljs-addition">+        let height = self.terminal.size().height;</span><br><span class="hljs-addition">+        for row in 0..height - 1 &#123;</span><br>             Terminal::clear_current_line();<br><span class="hljs-deletion">-            println!(&quot;~\r&quot;);</span><br><span class="hljs-addition">+            if row == height / 3 &#123;</span><br><span class="hljs-addition">+                println!(&quot;iTEditor -- version &#123;&#125;\r&quot;, VERSION)</span><br><span class="hljs-addition">+            &#125; else &#123;</span><br><span class="hljs-addition">+                println!(&quot;~\r&quot;)</span><br><span class="hljs-addition">+            &#125;</span><br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>我们在代码中添加了一个名为<code>VERSION</code>的常量。由于<code>Cargo.toml</code>文件已经包含了版本号，我们使用<code>env!</code>宏来检索它，并将其加入到我们的<code>Welcome Message</code>中。</p><p>然而，我们需要处理一个问题：由于终端尺寸的限制，我们的信息可能会被截断。现在我们就来解决这个问题。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -58,7 +58,10 @@</span> impl Editor &#123;<br>         for row in 0..height - 1 &#123;<br>             Terminal::clear_current_line();<br>             if row == height / 3 &#123;<br><span class="hljs-deletion">-                println!(&quot;iTEditor -- version &#123;&#125;\r&quot;, VERSION)</span><br><span class="hljs-addition">+                let welcome_messgae = format!(&quot;iTEditor -- version &#123;&#125;\r&quot;, VERSION);</span><br><span class="hljs-addition">+                let width =</span><br><span class="hljs-addition">+                    std::cmp::min(self.terminal.size().width as usize, welcome_messgae.len());</span><br><span class="hljs-addition">+                println!(&quot;&#123;&#125;\r&quot;, &amp;welcome_messgae[..width])</span><br>             &#125; else &#123;<br>                 println!(&quot;~\r&quot;)<br>             &#125;<br></code></pre></td></tr></table></figure><p><code>[...width]</code>意味着我们想要从字符串的开始进行切片，直到<code>width</code>为止，这里<code>width</code>被计算为屏幕宽度与欢迎信息长度的较小值，这确保了我们不会切除比已有内容更多的字符串部分。</p><p>现在，让我们将欢迎信息居中显示，同时，让我们把绘制欢迎信息的代码移到一个单独的函数中去。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,3 +1,5 @@</span><br><span class="hljs-addition">+use std::fmt::format;</span><br><span class="hljs-addition">+</span><br> use crate::Terminal;<br> use termion::event::Key;<br> <br><span class="hljs-meta">@@ -58,15 +60,23 @@</span> impl Editor &#123;<br>         for row in 0..height - 1 &#123;<br>             Terminal::clear_current_line();<br>             if row == height / 3 &#123;<br><span class="hljs-deletion">-                let welcome_messgae = format!(&quot;iTEditor -- version &#123;&#125;\r&quot;, VERSION);</span><br><span class="hljs-deletion">-                let width =</span><br><span class="hljs-deletion">-                    std::cmp::min(self.terminal.size().width as usize, welcome_messgae.len());</span><br><span class="hljs-deletion">-                println!(&quot;&#123;&#125;\r&quot;, &amp;welcome_messgae[..width])</span><br><span class="hljs-addition">+                self.draw_welcome_message();</span><br>             &#125; else &#123;<br>                 println!(&quot;~\r&quot;)<br>             &#125;<br>         &#125;<br>     &#125;<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+    fn draw_welcome_message(&amp;self) &#123;</span><br><span class="hljs-addition">+        let mut welcome_message = format!(&quot;iTEditor -- version &#123;&#125;\r&quot;, VERSION);</span><br><span class="hljs-addition">+        let width = self.terminal.size().width as usize;</span><br><span class="hljs-addition">+        let len = welcome_message.len();</span><br><span class="hljs-addition">+        let padding = width.saturating_sub(len) / 2;</span><br><span class="hljs-addition">+        let spaces = &quot; &quot;.repeat(padding.saturating_sub(1));</span><br><span class="hljs-addition">+        welcome_message = format!(&quot;~&#123;&#125;&#123;&#125;&quot;, spaces, welcome_message);</span><br><span class="hljs-addition">+        welcome_message.truncate(width);</span><br><span class="hljs-addition">+        println!(&quot;&#123;&#125;\r&quot;, welcome_message);</span><br><span class="hljs-addition">+    &#125;</span><br> &#125;<br></code></pre></td></tr></table></figure><p>要让一段文本居中显示，需要将屏幕宽度<code>/2</code>，然后从中减去字符串长度的一半。换句话说：<code>(width/2) - (welcome_len/2)</code>，简化后为<code>(width - welcome_len) / 2</code>。这告诉你从屏幕左边缘开始打印字符串应该离开多远。因此我们用空格字符填充这段空间，除了第一个字符，应该是波浪符号。<code>repeat</code>是一个很好的辅助函数，它重复我们传递给它的字符，而<code>truncate</code>在必要时将字符串缩短到特定宽度。</p><h2 id="移动光标">移动光标</h2><p>现在让我们编写输入部分，我们希望用户能够移动光标。第一步是在编辑器状态中跟踪光标的<code>x</code>和<code>y</code>位置。为此，我们将添加另一个结构体来帮助我们。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -1,12 +1,16 @@</span><br><span class="hljs-deletion">-use std::fmt::format;</span><br><span class="hljs-deletion">-</span><br> use crate::Terminal;<br> use termion::event::Key;<br> <br> const VERSION: &amp;str = env!(&quot;CARGO_PKG_VERSION&quot;);<br><span class="hljs-addition">+</span><br><span class="hljs-addition">+struct Position &#123;</span><br><span class="hljs-addition">+    x: usize,</span><br><span class="hljs-addition">+    y: usize,</span><br><span class="hljs-addition">+&#125;</span><br> pub struct Editor &#123;<br>     should_quit: bool,<br>     terminal: Terminal,<br><span class="hljs-addition">+    cursor_position: Position,</span><br> &#125;<br> <br> impl Editor &#123;<br><span class="hljs-meta">@@ -28,6 +32,7 @@</span> impl Editor &#123;<br>         Self &#123;<br>             should_quit: false,<br>             terminal: Terminal::default().expect(&quot;Failed to initialize terminal&quot;),<br><span class="hljs-addition">+            cursor_position: Position &#123; x: 0, y: 0 &#125;,</span><br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><p><code>cursor_position</code>结构体负责追踪光标在编辑文档中的水平和垂直坐标，其起始点设为屏幕的左上角<code>(0,0)</code>。不过，它不是作为<code>Terminal</code>结构体的一部分来处理的，因为它代表的是光标在文档中的位置，而不是在终端界面上的位置。此外，尽管终端尺寸采用<code>u16</code>类型，可能仅支持到<code>65,000</code>行，但对于光标位置，我们选择了<code>usize</code>类型，因为它根据编译的目标架构的不同，可以是<code>32位</code>或<code>64位</code>，这样可以支持更大的文档。</p><p>现在，我们要给<code>refresh_screen()</code>函数增加代码，使其能够将光标移动到<code>cursor_position</code>中储存的位置。同时，我们也将重新编写<code>cursor_position</code>，使其能接受一个<code>Position</code>类型的参数。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -3,9 +3,9 @@</span> use termion::event::Key;<br> <br> const VERSION: &amp;str = env!(&quot;CARGO_PKG_VERSION&quot;);<br> <br><span class="hljs-deletion">-struct Position &#123;</span><br><span class="hljs-deletion">-    x: usize,</span><br><span class="hljs-deletion">-    y: usize,</span><br><span class="hljs-addition">+pub struct Position &#123;</span><br><span class="hljs-addition">+    pub x: usize,</span><br><span class="hljs-addition">+    pub y: usize,</span><br> &#125;<br> pub struct Editor &#123;<br>     should_quit: bool,<br><span class="hljs-meta">@@ -39,13 +39,13 @@</span> impl Editor &#123;<br>     fn refresh_screen(&amp;self) -&gt; Result&lt;(), std::io::Error&gt; &#123;<br>         Terminal::cursor_hide();<br>         Terminal::clear_screen();<br><span class="hljs-deletion">-        Terminal::cursor_position(0, 0);</span><br><span class="hljs-addition">+        Terminal::cursor_position(&amp;Position &#123; x: 0, y: 0 &#125;);</span><br>         if self.should_quit &#123;<br>             Terminal::clear_screen();<br>             println!(&quot;Goodbye.\r&quot;);<br>         &#125; else &#123;<br>             self.draw_rows();<br><span class="hljs-deletion">-            Terminal::cursor_position(0, 0);</span><br><span class="hljs-addition">+            Terminal::cursor_position(&amp;self.cursor_position);</span><br>         &#125;<br>         Terminal::cursor_show();<br>         Terminal::flush()<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>scr/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -5,6 +5,7 @@</span> mod terminal;<br> <br> use editor::Editor;<br> pub use terminal::Terminal;<br><span class="hljs-addition">+pub use editor::Position;</span><br> <br> fn main() &#123;<br>     Editor::default().run()<br></code></pre></td></tr></table></figure><figure class="highlight diff"><figcaption><span>src/terminal.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -3,6 +3,8 @@</span> use termion::event::Key;<br> use termion::input::TermRead;<br> use termion::raw::&#123;IntoRawMode, RawTerminal&#125;;<br> <br><span class="hljs-addition">+use crate::editor::Position;</span><br><span class="hljs-addition">+</span><br> pub struct Size &#123;<br>     pub width: u16,<br>     pub height: u16,<br><span class="hljs-meta">@@ -33,9 +35,12 @@</span> impl Terminal &#123;<br>         print!(&quot;&#123;&#125;&quot;, termion::clear::All);<br>     &#125;<br> <br><span class="hljs-deletion">-    pub fn cursor_position(x: u16, y: u16) &#123;</span><br><span class="hljs-addition">+    pub fn cursor_position(position: &amp;Position) &#123;</span><br><span class="hljs-addition">+        let Position &#123; mut x, mut y &#125; = position;</span><br>         let x = x.saturating_add(1);<br>         let y = y.saturating_add(1);<br><span class="hljs-addition">+        let x = x as u16;</span><br><span class="hljs-addition">+        let y = y as u16;</span><br>         print!(&quot;&#123;&#125;&quot;, termion::cursor::Goto(x, y));<br>     &#125;<br></code></pre></td></tr></table></figure><p>我们正在使用解构<code>(destructuring)</code>来初始化<code>cursor_position</code>中的<code>x</code>和<code>y</code>：<code>let Position&#123;mut x, mut y&#125; = position</code>; 这会创建新的变量<code>x</code>和<code>y</code>，并将它们绑定到<code>position</code>中同名的字段。</p><p>我们还将在<code>Position</code>中的<code>usize</code>数据类型转换为<code>u16</code>。如果<code>u16</code>无法容纳足够大的值，那么值将被截断。目前这样做没问题——我们稍后会添加逻辑以确保我们始终在<code>u16</code>的边界内——因此我们在这里添加了一个小指令，以避免<code>Clippy</code>因此类错误而打扰我们。</p><p>提到<code>Clippy</code>的烦人警告，我们目前有一个旧警告需要解决。接下来，我们将允许用户使用箭头键移动光标。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -55,11 +57,24 @@</span> impl Editor &#123;<br>         let pressed_key = Terminal::read_key()?;<br>         match pressed_key &#123;<br>             Key::Ctrl(&#x27;q&#x27;) =&gt; self.should_quit = true,<br><span class="hljs-addition">+            Key::Up | Key::Down | Key::Left | Key::Right =&gt; self.move_cursor(pressed_key),</span><br>             _ =&gt; (),<br>         &#125;<br>         Ok(())<br>     &#125;<br> <br><span class="hljs-addition">+    fn move_cursor(&amp;mut self, key: Key) &#123;</span><br><span class="hljs-addition">+        let Position &#123; mut x, mut y &#125; = self.cursor_position;</span><br><span class="hljs-addition">+        match key &#123;</span><br><span class="hljs-addition">+            Key::Up =&gt; y = y.saturating_sub(1),</span><br><span class="hljs-addition">+            Key::Down =&gt; y = y.saturating_add(1),</span><br><span class="hljs-addition">+            Key::Left =&gt; x = x.saturating_sub(1),</span><br><span class="hljs-addition">+            Key::Right =&gt; x = x.saturating_add(1),</span><br><span class="hljs-addition">+            _ =&gt; (),</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+        self.cursor_position = Position &#123; x, y &#125;</span><br><span class="hljs-addition">+    &#125;</span><br><span class="hljs-addition">+</span><br>     fn draw_rows(&amp;self) &#123;<br>         let height = self.terminal.size().height;<br>         for row in 0..height - 1 &#123;<br></code></pre></td></tr></table></figure><p>现在我们可以通过方向键来移动光标了。</p><h2 id="防止光标移出屏幕">防止光标移出屏幕</h2><p>目前，光标位置<code>cursor_position</code>的值可能会超出屏幕的右侧和底部边界。我们可以通过在<code>move_cursor()</code>函数中进行边界检查来预防这一问题。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -65,11 +63,22 @@</span> impl Editor &#123;<br> <br>     fn move_cursor(&amp;mut self, key: Key) &#123;<br>         let Position &#123; mut x, mut y &#125; = self.cursor_position;<br><span class="hljs-addition">+        let size = self.terminal.size();</span><br><span class="hljs-addition">+        let height = size.height.saturating_sub(1) as usize;</span><br><span class="hljs-addition">+        let width = size.width.saturating_sub(1) as usize;</span><br>         match key &#123;<br>             Key::Up =&gt; y = y.saturating_sub(1),<br><span class="hljs-deletion">-            Key::Down =&gt; y = y.saturating_add(1),</span><br><span class="hljs-addition">+            Key::Down =&gt; &#123;</span><br><span class="hljs-addition">+                if y &lt; height &#123;</span><br><span class="hljs-addition">+                    y = y.saturating_add(1);</span><br><span class="hljs-addition">+                &#125;</span><br><span class="hljs-addition">+            &#125;</span><br>             Key::Left =&gt; x = x.saturating_sub(1),<br><span class="hljs-deletion">-            Key::Right =&gt; x = x.saturating_add(1),</span><br><span class="hljs-addition">+            Key::Right =&gt; &#123;</span><br><span class="hljs-addition">+                if x &lt; width &#123;</span><br><span class="hljs-addition">+                    x = x.saturating_add(1);</span><br><span class="hljs-addition">+                &#125;</span><br><span class="hljs-addition">+            &#125;</span><br>             _ =&gt; (),<br>         &#125;<br>         self.cursor_position = Position &#123; x, y &#125;<br></code></pre></td></tr></table></figure><p>你应该能够确认现在可以在可见区域内移动光标，并且光标会保持在终端的边界内。你还可以将光标放在最后一行，尽管那里目前还没有<code>~</code>。</p><h2 id="映射功能键">映射功能键</h2><p>为了完善我们的低级终端代码，我们需要检测一些更特殊的按键操作。我们将映射<code>Page Up</code>、<code>Page Down</code>、<code>Home</code>和<code>End</code>键，以便分别将光标定位到屏幕的顶部或底部，或是行的开头或末尾。</p><figure class="highlight diff"><figcaption><span>src/editor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -55,7 +55,14 @@</span> impl Editor &#123;<br>         let pressed_key = Terminal::read_key()?;<br>         match pressed_key &#123;<br>             Key::Ctrl(&#x27;q&#x27;) =&gt; self.should_quit = true,<br><span class="hljs-deletion">-            Key::Up | Key::Down | Key::Left | Key::Right =&gt; self.move_cursor(pressed_key),</span><br><span class="hljs-addition">+            Key::Up</span><br><span class="hljs-addition">+            | Key::Down</span><br><span class="hljs-addition">+            | Key::Left</span><br><span class="hljs-addition">+            | Key::Right</span><br><span class="hljs-addition">+            | Key::Home</span><br><span class="hljs-addition">+            | Key::End</span><br><span class="hljs-addition">+            | Key::PageUp</span><br><span class="hljs-addition">+            | Key::PageDown =&gt; self.move_cursor(pressed_key),</span><br>             _ =&gt; (),<br>         &#125;<br>         Ok(())<br><span class="hljs-meta">@@ -79,6 +86,10 @@</span> impl Editor &#123;<br>                     x = x.saturating_add(1);<br>                 &#125;<br>             &#125;<br><span class="hljs-addition">+            Key::Home =&gt; x = 0,</span><br><span class="hljs-addition">+            Key::End =&gt; x = width,</span><br><span class="hljs-addition">+            Key::PageUp =&gt; y = 0,</span><br><span class="hljs-addition">+            Key::PageDown =&gt; y = height,</span><br>             _ =&gt; (),<br>         &#125;<br>         self.cursor_position = Position &#123; x, y &#125;<br></code></pre></td></tr></table></figure><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/156e55dd.html">https://zone.ivan-zhang.com.cn/p/156e55dd.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>TextEditor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust学习-制作一个文本编辑器: Reading User Input</title>
    <link href="/p/8e0787d5.html"/>
    <url>/p/8e0787d5.html</url>
    
    <content type="html"><![CDATA[<h2 id="读取用户的输入">读取用户的输入</h2><p>现在来尝试读取用户的输入操作，<code>main.rs</code>如下：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b.<span class="hljs-title function_ invoke__">unwrap</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>use</code>类似于<code>import</code>或<code>include</code>，用来引入我们要使用的库。在这里我们使用<code>io</code>用来进行输入输出操作<code>use std::io::&#123;self, Read&#125;;</code>，这一步相当于：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br></code></pre></td></tr></table></figure><p><code>main</code>函数中主要包含一个循环，其中<code>io::stdin().bytes()</code>将返回一个<strong>迭代器</strong>，在每一轮循环前赋值给<code>b</code>后进入循环，直到没有可以读的内容了。我们可以通过<code>Ctrl+D</code>来发出<code>eof</code>，或者直接<code>Ctrl+C</code>来终止程序。</p><p>在实际运行的时候，这个程序会将用户输入的字符串打印出来。然而，在默认情况下，仅当用户按下<code>Enter</code>时输入才会发送给程序，这也允许用户通过·来编辑修复内容（<code>canonical mode / cooked mode</code>），但是对于一个文本编辑器来说，我们希望在按下键盘时程序能立刻响应（<code>raw mode</code>）。</p><h2 id="输入Q来退出">输入<code>Q</code>来退出</h2><p>当程序收到用户按下<code>Q</code>时，退出程序：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b.<span class="hljs-title function_ invoke__">unwrap</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;q&#x27;</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，在<code>Rust</code>中，字符需要用单引号<code>''</code>包裹，字符串是双引号<code>&quot;&quot;</code>，这和<code>C++</code>是类似的。</p><p>现在当我们在程序中输入<code>q</code>，循环将停止，程序就会退出了，而在<code>q</code>后面的字符不会被打印，并在程序退出时一起被销毁。</p><h2 id="Raw-Mode">Raw Mode</h2><p>为了切换到<code>Raw Mode</code>，我们需要使用<code>termion</code>，可以在<code>Cargo.toml</code>中引入：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">termion</span> = <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><p>我们再次运行<code>cargo build</code>或<code>run</code>，就会下载并编译<code>termion</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">Updating</span> crates.io index<br><span class="hljs-attribute">Downloaded</span> libc v0.<span class="hljs-number">2</span>.<span class="hljs-number">150</span><br><span class="hljs-attribute">Downloaded</span> numtoa v0.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Downloaded</span> termion v1.<span class="hljs-number">5</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">Downloaded</span> <span class="hljs-number">3</span> crates (<span class="hljs-number">751</span>.<span class="hljs-number">0</span> KB) in <span class="hljs-number">6</span>.<span class="hljs-number">06</span>s<br> <span class="hljs-attribute">Compiling</span> libc v0.<span class="hljs-number">2</span>.<span class="hljs-number">150</span><br> <span class="hljs-attribute">Compiling</span> numtoa v0.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br> <span class="hljs-attribute">Compiling</span> termion v1.<span class="hljs-number">5</span>.<span class="hljs-number">6</span><br> <span class="hljs-attribute">Compiling</span> iTEditor v0.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> (/root/iTEditor)<br>  <span class="hljs-attribute">Finished</span> dev<span class="hljs-meta"> [unoptimized + debuginfo] target(s) in 11.53s</span><br></code></pre></td></tr></table></figure><p>现在让我们把<code>main.rs</code>中的代码改写成支持<code>raw mode</code>的：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, stdout, Read&#125;;<br><span class="hljs-keyword">use</span> termion::raw::IntoRawMode;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b.<span class="hljs-title function_ invoke__">unwrap</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;q&#x27;</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用<code>termion</code>提供<code>stdout()</code>并调用<code>into_raw_mode()</code>函数。为什么要在<code>stdout</code>而不是<code>stdin</code>呢？因为终端的状态是由写入者控制而不是读取者。<code>writer</code>用于在屏幕上绘图或移动光标，同时也用于修改模式。</p><p>除此之外，我们还新建了<code>_stdout</code>变量，用于储存<code>into_raw_mode()</code>的返回，但是从未在之后的程序中使用过它。这涉及到Rust中<strong>所有权</strong>的概念，简单来说，终端可以拥有一些属性，不属于自己的东西将会被移除，而<code>into_raw_mode()</code>修改了终端并返回了一个值，我们需要将它储存起来，通过绑定到<code>_stdout</code>变量，一旦删除<code>_stdout</code>，终端就又会变为<code>canonical mode</code>。<code>_stdout</code>的变量名中添加了前缀<code>_</code>，这会告诉编译器我们希望保留这个变量即使没有被使用过，否则在编译时回返回一个<code>warning</code>。</p><p>运行一下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">   Compiling iTEditor v0.<span class="hljs-number">1.0</span> (<span class="hljs-regexp">/root/i</span>TEditor)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.13</span>s<br>     Running `target<span class="hljs-regexp">/debug/i</span>TEditor`<br>d<br> s<br>  j<br>   f<br>    h<br>     s<br>      r<br>       i<br>        <span class="hljs-number">1</span><br>         q<br>          <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h2 id="监视按键">监视按键</h2><p>为了更好的探索<code>Raw Mode</code>的工作，我们让程序输出读到的所有<code>byte</code>：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = b.<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br><span class="hljs-keyword">if</span> c.<span class="hljs-title function_ invoke__">is_control</span>()&#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; \r&quot;</span>, b);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; (&#123;&#125;)\r&quot;</span>, b, c);<br>&#125;<br><span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;q&#x27;</span> &#123;<br><span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中对变量<code>b</code>进行了二次声明，这是叫做<strong>变量遮蔽</strong>的特性：在新变量的作用域中，原先的变量会被屏蔽，这样就不必费心思想新的变量名了。函数<code>is_control()</code>可以用来判断是否是控制字符。控制字符是不可被打印出来的，我们可以在<code>ASCII</code>表中找到他们。</p><center>  <img src="https://cdn.ttgtmedia.com/rms/onlineimages/non_printing_ascii_control_codes-f.png" alt="ASCII" style="zoom:50%;" />  <br>  <font color="DimGray" size="3">Non-printing ASCII control codes.</font></center><p>通过测试我们可以发现，<code>Ctrl+A...Z</code>对应的就是<code>ASCII</code>表中1-26的控制符。</p><h2 id="按Ctrl-Q退出">按<code>Ctrl+Q</code>退出</h2><p>现在我们可以将<code>Ctrl+Q</code>映射到退出操作：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_ctrl_byte</span>(c: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = c <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;<br>    byte &amp; <span class="hljs-number">0b0001_1111</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_stdout</span> = <span class="hljs-title function_ invoke__">stdout</span>().<span class="hljs-title function_ invoke__">into_raw_mode</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">/*codes*/</span><br>        <span class="hljs-keyword">if</span> b == <span class="hljs-title function_ invoke__">to_ctrl_byte</span>(<span class="hljs-string">&#x27;q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数<code>to_ctrl_byte()</code>将返回字符和<code>00011111</code>相与的二进制结果。</p><h2 id="异常处理">异常处理</h2><p>现在是时候该旅一下如何处理错误了。我们给程序增加一个<code>die()</code>函数打印错误并退出：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">die</span>(e: std::io::Error)&#123;<br>    <span class="hljs-built_in">panic!</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>panic!</code>会导致程序关闭并输出错误信息。和其他语言不一样，<code>Rust</code>没有类似于<code>try...catch</code>的结构来捕获可能发生的错误，取而代之的是，<code>Rust</code>采用一种将错误作为函数返回值的方式进行传递，这样我们就可以在程序的顶层统一处理这些错误。</p><p>在<code>Rust</code>中，当函数可能发生错误时，它会返回一个名为<code>Result</code>的类型。<code>Result</code>是一个包装器，内含期望的结果或一个错误。在这种情况下，每一个值<code>b</code>本质上都是一个<code>Result</code>，它要么包含一个表示已读取字节的<code>Ok</code>，要么包含一个<code>Err</code>，后者包装了一个错误对象，表明在读取字节时出现了问题。为了得到我们需要的值，我们可以调用<code>unwrap</code>方法：如果我们得到的是<code>Ok</code>，就返回它包含的值；如果是<code>Err</code>，则触发<code>panic</code>。</p><p>我们希望在错误发生时自行控制程序崩溃，而不是让Rust直接触发<code>panic</code>，因为后续我们想在程序崩溃前清除屏幕，避免给用户留下未完成绘制的输入信息。目前，我们只需检查错误然后调用<code>die</code>函数，这个函数会替我们执行<code>panic</code>。</p><p>我们通过枚举（<code>match</code>）来实现这个流程，<code>match</code>可以当成一个增强版的<code>if-then-else</code>。由它处理变量<code>b</code>，这个变量要么包含我们想要的值，这个值被<code>Ok</code>包装，要么包含一个错误，这个错误被<code>Err</code>包装：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>    <span class="hljs-keyword">match</span> b&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(b) =&gt; &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br>            <span class="hljs-keyword">if</span> c.<span class="hljs-title function_ invoke__">is_control</span>() &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; \r&quot;</span>, b);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; (&#123;&#125;)\r&quot;</span>, b, c);<br>            &#125;<br>            <span class="hljs-keyword">if</span> b == <span class="hljs-title function_ invoke__">to_ctrl_byte</span>(<span class="hljs-string">&#x27;q&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-title function_ invoke__">die</span>(err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/8e0787d5.html">https://zone.ivan-zhang.com.cn/p/8e0787d5.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>TextEditor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust学习-制作一个文本编辑器: Setup</title>
    <link href="/p/e62fb29b.html"/>
    <url>/p/e62fb29b.html</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>参考 <a href="https://www.flenker.blog/hecto/">https://www.flenker.blog/hecto</a></p>          </div><h2 id="安装Rust">安装Rust</h2><p>可以通过访问<a href="https://rustup.rs/">rustup</a>网站，它会尝试自动检测操作系统并显示安装 <code>rustup</code> 的最佳方法。通常，执行以下脚本 ，<code>rustup-init</code>会自动完成安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh<br></code></pre></td></tr></table></figure><p>当终端输出<code>Rust is installed now. Great!</code>时，代表<code>Rust</code>安装成功。这时候需要重启终端或者执行<code>source $HOME/.cargo/env</code>，就可以使用<code>Rust</code>了。</p><h3 id="检查安装">检查安装</h3><p>要验证<code>Rust</code>是否已正确安装，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustc --version<br></code></pre></td></tr></table></figure><p>要验证<code>Cargo</code>是否已正确安装，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo --version<br></code></pre></td></tr></table></figure><p>正常情况下，会得到程序名称、版本号和一些其他信息的输出。</p><h2 id="初始化iTEditor项目">初始化iTEditor项目</h2><p>在当前目录创建项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo init iTEditor<br></code></pre></td></tr></table></figure><p><code>iTEditor</code>是项目的名称（在<code>Rust</code>中，项目名称需要用<code>snake case</code>命名法，这个显然是不符合要求的，可以改成<code>i_text_editor</code>，我还是感觉我的好看，这里就不改了hh），执行完后会创建一个<code>iTEditor</code>文件夹，它已经设置好了<code>git</code>。</p><p>我们来查看一下目录结构：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  iTEditor git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.toml</span><br>└── <span class="hljs-attribute">src</span><br>    └── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span><br><br><span class="hljs-number">1</span> directory, <span class="hljs-number">2</span> files<br></code></pre></td></tr></table></figure><p>新的项目包含两个主要文件，其中<code>Cargo.toml</code>相当于<code>package.json</code>，主要记录当前项目所需要的依赖：</p><figure class="highlight rust"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">[package]<br>name = <span class="hljs-string">&quot;iTEditor&quot;</span><br>version = <span class="hljs-string">&quot;0.1.0&quot;</span><br>edition = <span class="hljs-string">&quot;2021&quot;</span><br><br># See more keys and their definitions at https:<span class="hljs-comment">//doc.rust-lang.org/cargo/reference/manifest.html</span><br><br>[dependencies]<br></code></pre></td></tr></table></figure><p>src/main.rs中包含了项目的源码：</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译与运行">编译与运行</h3><p>在项目根文件夹中，运行<code>cargo build</code>进行编译，这将输出类似于以下内容：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">Compiling iTEditor v0<span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.0</span> (/root/iTEditor)<br> Finished dev <span class="hljs-selector-attr">[unoptimized + debuginfo]</span> <span class="hljs-built_in">target</span>(s) in <span class="hljs-number">0.10s</span><br></code></pre></td></tr></table></figure><p>这将生成一个名为<code>iTEditor</code>的可执行文件，并将其放置在名为<code>target/debug/</code>的新文件夹中。此外还有一个<code>Cargo.lock</code>文件，里面记录了每个库使用的精确的版本，不需要碰它。</p><p>在<code>target/debug/</code>目录中可以找到生成的可运行文件<code>iTEditor</code>，直接运行它，就会输出<code>Hello, world!</code>。</p><p>以上的步骤都可以通过<code>cargo run</code>来一步到位：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">   Compiling iTEditor v0.<span class="hljs-number">1.0</span> (<span class="hljs-regexp">/root/i</span>TEditor)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.13</span>s<br>     Running `target<span class="hljs-regexp">/debug/i</span>TEditor`<br>Hello, world!<br></code></pre></td></tr></table></figure><p>至此，就是一个<code>Rust</code>项目创建、编译与运行的所有流程了。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/e62fb29b.html">https://zone.ivan-zhang.com.cn/p/e62fb29b.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>TextEditor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144计算机网络Lab3: The TCP Sender</title>
    <link href="/p/785ad61c.html"/>
    <url>/p/785ad61c.html</url>
    
    <content type="html"><![CDATA[<center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/15/652c095ff0876.png" alt="CS144TCPSocket" style="zoom:25%;" /><br>  <font color="DimGray" size="3">The arrangement of modules and dataflow in TCP implementation.</font></center><p>在<code>Lab3</code>中，需要实现一个<code>TCPSender</code>，主要有以下几个功能：</p><ul><li>根据接收方的响应调整发送窗口；</li><li>发送<code>SYN</code>，<code>FIN</code>报文；</li><li>从<code>ByteStream</code>中读取、创建并发送新的<code>TCPSegment</code>；</li><li>跟踪已发送的<code>Segment</code>，直到被确认接收，必要时进行<code>超时重传</code>。</li></ul><h2 id="A-How-does-the-TCPSender-know-if-a-segment-was-lost">A. How does the TCPSender know if a segment was lost?</h2><blockquote><p>在<code>Lab0</code>中介绍过，<code>TCP</code>是在不可靠的链路上提供<strong>尽力而为</strong>的可靠传输。为了实现这一目的，在<code>TCP</code>中，<code>TCPSender</code>需要确保每一个<code>Segment</code>都被成功接收。</p></blockquote><p>每当一个<code>Segment</code>被发送出去，<code>TCPSender</code>会记录其发送的时间并标记为<strong>未完成的</strong>，当超过<code>retransmission timeout(RTO)</code>毫秒后，如果依然没有确认收到，就会进行重传。</p><p>这是由一个全局的计时器来实现的，具体来说，<code>TCPSender</code>的重传遵循以下几个规则：</p><ul><li>每隔一段时间(毫秒)，<code>TCPSender</code>的<code>Tick()</code>方法会被调用，并带有一个参数<code>ms_since_last_tick</code>代表<strong>自上次调用该方法以来已经过去了多少毫秒</strong>。</li><li>当<code>TCPSender</code>被构造时，会附带一个<code>_initial_retransmission_timeout</code>参数，代表<strong>重传时限<code>(retransmission timeout, RTO)</code></strong> 的初始值。<code>RTO</code>是重新发送未完成的<code>TCP Segment</code>前要等待的毫秒数。随着通信进行，<code>RTO</code>可能会发生变化，但是初始值保持不变。</li><li>每次发送携带数据的<code>Segment</code>时，如果计时器<code>(Timer)</code>没有运行，就启动它。</li><li>当所有未完成的<code>Segment</code>都被确认后，停止<code>Timer</code>。</li><li>当<code>Tick()</code>函数被调用，且已经过期时：<ul><li>立即重传最早的未被确认的<code>Segment</code>。</li><li>如果<code>window size</code>非零：<strong>(指数退避)</strong><ul><li>记录连续重传次数<code>consecutive retransmissions</code>，并在发生重传时增加它。</li><li><code>RTO *= RTO</code>。</li></ul></li><li>重启<code>Timer</code>。</li></ul></li><li>当接收方向发送方发出了新的确认时：<ul><li>重置<code>RTO</code>为<strong>初始值</strong>。</li><li>如果<code>Sender</code>中还有未被确认的<code>Segment</code>，就重置<code>Timer</code>，并使其在<code>RTO</code>毫秒后过期。</li><li>归零重传计数器。</li></ul></li></ul><p><code>Time</code>代码如下：</p><figure class="highlight c++"><figcaption><span>tcp_sender.hh&tcp_sender.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*************************tcp_sender.hh*************************/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> _is_running&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _consecutive_retransmissions_times&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _retransmission_timeout&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _time_passed&#123;<span class="hljs-number">0</span>&#125;;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Timer</span>();<br><br><span class="hljs-comment">/*************************tcp_sender.cc*************************/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Timer::start</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _initial_retransmission_timeout)</span> </span>&#123;<br>    _is_running = <span class="hljs-literal">true</span>;<br>    _consecutive_retransmissions_times = <span class="hljs-number">0</span>;<br>    _retransmission_timeout = _initial_retransmission_timeout;<br>    _time_passed = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Timer::stop</span><span class="hljs-params">()</span> </span>&#123; _is_running = <span class="hljs-literal">false</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Timer::reset</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _initial_retransmission_timeout)</span> </span>&#123;<br>    <span class="hljs-built_in">stop</span>();<br>    <span class="hljs-built_in">start</span>(_initial_retransmission_timeout);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Timer::restart</span><span class="hljs-params">()</span> </span>&#123; _time_passed = <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Timer::time_update</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ms_since_last_tick)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_is_running)<br>        _time_passed += ms_since_last_tick;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Timer::exponential_backoff</span><span class="hljs-params">()</span> </span>&#123;<br>    _consecutive_retransmissions_times++;<br>    _retransmission_timeout *= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Timer::check_expired</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ms_since_last_tick)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_is_running) &#123;<br>        <span class="hljs-built_in">time_update</span>(ms_since_last_tick);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_time_passed &gt;= _retransmission_timeout) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Timer::is_running</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_running; &#125;<br></code></pre></td></tr></table></figure><h2 id="B-Implementing-the-TCP-sender">B. Implementing the TCP sender</h2><h3 id="Evolution-of-the-TCP-sender">Evolution of the TCP sender</h3><p>现在我们可以来实现一下<code>TCPSender</code>了。首先我们需要了解一下<code>Sender</code>的各种状态:</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/11/23/655f5c6b0ce89.png" alt="EvolutionTCPSender" style="zoom:50%;" /><br>  <font color="DimGray" size="3">Evolution of the TCP sender (as tested by the test suite).</font></center><p>在<code>CS144</code>中，各个状态能干的事情，其中在<code>CLOSED</code>和<code>SYN_ACKED</code>状态时，在发送SYN和FIN信号的同时也是可以携带数据的(不过我觉得现实中应该是不可以的)。除此之外，在<code>SYN_SENT</code>状态发完<code>SYN</code>还是可以继续发只有数据的<code>Segment</code>，分的不是很清楚。</p><table><thead><tr><th style="text-align:center"><strong>状态</strong></th><th style="text-align:center"><strong>发送信号</strong></th><th style="text-align:center"><strong>发送数据</strong></th><th style="text-align:center"><strong>重传数据</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>CLOSED</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>SYN_SENT</strong></td><td style="text-align:center">0</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>SYN_ACKED</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>FIN_SENT</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>FIN_ACKED</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>ERROR</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><h3 id="Functions-of-the-TCP-sender">Functions of the TCP sender</h3><h4 id="成员变量">成员变量</h4><p>我添加了以下几个成员变量，其中<code>_segments_cache</code>用来储存还未确认收到的Segment，<code>_ackno</code>用来记录确认收到的最大的<code>seqno</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">Timer _timer&#123;&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _window_size&#123;<span class="hljs-number">0</span>&#125;;<br>std::queue&lt;TCPSegment&gt; _segments_cache&#123;&#125;;<br><span class="hljs-type">uint64_t</span> _ackno&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">_status</span> &#123; CLOSED, SYN_SENT, SYN_ACKED, FIN_SENT, FIN_ACKED, ERROR &#125; _status&#123;CLOSED&#125;;<br></code></pre></td></tr></table></figure><h4 id="bytes-in-flight"><code>bytes_in_flight()</code></h4><p>返回未被确认的<code>Segment</code>数量，直接用下一个未发送<code>seqno</code>减去最后一个被确认的<code>seqno</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <br>  <span class="hljs-keyword">return</span> _next_seqno - _ackno; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fill-window"><code>fill_window()</code></h4><p>先计算一下这一次调用最多能发送多少数据<code>fill_size</code>：用<code>window size</code>减去目前未确认的<code>Segment</code>。需要注意的是当状态为<code>CLOSE</code>的时候，<code>window size</code>是<code>0</code>，这个时候可以发送<code>syn</code>，我们可以把<code>window size</code>当作<code>1</code>。</p><p>那么显然，当状态是<code>CLOSE</code>或者<code>fill_size &gt; 0</code>且<code>fin</code>未发送时，我们就可以主动发送<code>Segment</code>了。</p><p>当状态时<code>CLOSE</code>时，我们就可以开启一个<code>TCP</code>链接了，发送一个<code>syn</code>信号，并将<code>seqno</code>设置为<code>_isn</code>，状态更新成<code>SYN SENT</code>。</p><p>当状态是<code>SYN SENT</code>（<code>CS144</code>中<code>SYN Segment</code>也可能携带数据）或<code>SYN ACKED</code>且有需要发送的数据（发送正常的纯数据<code>Segment</code>）或数据流终止（关闭<code>TCP</code>，发送<code>fin</code>）时：</p><ul><li>先计算能填装的数据量，<code>fill_size</code>和<code>MAX_PAYLOAD_SIZE</code>取最小。</li><li>填装数据。</li><li>如果装完之后发现数据流终止了，我们就可以设置<code>fin</code>信号了。（注意<code>fin</code>也会占用一个<code>seqno</code>，所以需要先确认这次发送是否能装下，否则就要等下一轮了）</li><li>将<code>Segment</code>发送出去，并更新<code>_next_seqno</code>。</li></ul><p>如果在发送<code>Segment</code>时<code>Timer</code>没有运行的话，就启动<code>Timer</code>。</p><p>如果当前轮已发送的是一个不含数据的Segment，即指包含了信号的话，就可以直接结束这次发送了。如果含有数据，我们还需要更新一下fill_size，继续发送。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::fill_window</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> fill_size = (_window_size ? _window_size : <span class="hljs-number">1</span>) - <span class="hljs-built_in">bytes_in_flight</span>();<br>    <span class="hljs-keyword">while</span> (_status == CLOSED || (fill_size &amp;&amp; _status != FIN_SENT)) &#123;<br>        TCPSegment segment;<br>        <span class="hljs-keyword">if</span> (_status == CLOSED) &#123;<br>            segment.<span class="hljs-built_in">header</span>().syn = <span class="hljs-literal">true</span>;<br>            segment.<span class="hljs-built_in">header</span>().seqno = _isn;<br>            _status = SYN_SENT;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (_status == SYN_SENT <span class="hljs-built_in">or</span> (_status == SYN_ACKED &amp;&amp; (!_stream.<span class="hljs-built_in">buffer_empty</span>() <span class="hljs-keyword">or</span> _stream.<span class="hljs-built_in">eof</span>()))) &#123;<br>            <span class="hljs-type">size_t</span> payload_len =<br>                <span class="hljs-built_in">min</span>(fill_size, TCPConfig::MAX_PAYLOAD_SIZE);<br>            segment.<span class="hljs-built_in">header</span>().seqno = <span class="hljs-built_in">wrap</span>(_next_seqno, _isn);<br>            segment.<span class="hljs-built_in">payload</span>() = _stream.<span class="hljs-built_in">read</span>(payload_len);<br>            <span class="hljs-keyword">if</span> (_stream.<span class="hljs-built_in">eof</span>() &amp;&amp; fill_size-segment.<span class="hljs-built_in">length_in_sequence_space</span>()) &#123;<br>                segment.<span class="hljs-built_in">header</span>().fin = <span class="hljs-literal">true</span>;<br>                _status = FIN_SENT;<br>            &#125;<br>            _segments_out.<span class="hljs-built_in">push</span>(segment);<br>            _segments_cache.<span class="hljs-built_in">push</span>(segment);<br>            _next_seqno += segment.<span class="hljs-built_in">length_in_sequence_space</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!_timer.<span class="hljs-built_in">is_running</span>()) &#123;<br>            _timer.<span class="hljs-built_in">start</span>(_initial_retransmission_timeout);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!segment.<span class="hljs-built_in">length_in_sequence_space</span>())<br>            <span class="hljs-keyword">return</span>;<br>        fill_size -= segment.<span class="hljs-built_in">length_in_sequence_space</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ack-received"><code>ack_received()</code></h4><p>先将收到的<code>ackno</code>转换成<code>absoult seqno</code>，并确保其在我们可接受地范围内（在未确认的<code>seqno</code>之中）。</p><p>如果当前状态是<code>SYN SENT</code>则更新成<code>SYN ACKED</code>，并清除缓存<code>_segments_cache</code>中对应的<code>Segment</code>，并<strong>重置</strong><code>Timer</code>。需要注意的是，对于含有<code>fin</code>信号的<code>Segment</code>，我们需要单独处理，在这个环节就将它排除了。</p><p>若此时状态是<code>FIN SENT</code>且已经确认到了<code>fin</code>信号（注意<code>syn</code>和<code>fin</code>都会占一个<code>seqno</code>，且<code>seqno</code>是从<code>0</code>开始的），则更新成<code>FIN ACKED</code>，并清除缓存。</p><p>最后，如果缓存是空的，则<strong>停止</strong><code>Timer</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::ack_received</span><span class="hljs-params">(<span class="hljs-type">const</span> WrappingInt32 ackno, <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> window_size)</span> </span>&#123;<br>    <span class="hljs-type">uint64_t</span> absoult_ackno = <span class="hljs-built_in">unwrap</span>(ackno, _isn, _ackno);<br>    <span class="hljs-keyword">if</span> (absoult_ackno &lt; _ackno || absoult_ackno &gt; _next_seqno) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    _ackno = absoult_ackno;<br>    _window_size = window_size;<br><br>    <span class="hljs-keyword">if</span> (_status == SYN_SENT)<br>        _status = SYN_ACKED;<br><br>    <span class="hljs-keyword">while</span> (!_segments_cache.<span class="hljs-built_in">empty</span>() &amp;&amp;<br>           <span class="hljs-built_in">unwrap</span>(_segments_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().seqno, _isn, _ackno) &lt; <span class="hljs-built_in">unwrap</span>(ackno, _isn, _ackno) &amp;&amp; !_segments_cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().fin) &#123;<br>        _segments_cache.<span class="hljs-built_in">pop</span>();<br>        _timer.<span class="hljs-built_in">reset</span>(_initial_retransmission_timeout);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_status == FIN_SENT &amp;&amp; _ackno == _next_seqno) &#123;<br>        _status = FIN_ACKED;<br>        _segments_cache.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_segments_cache.<span class="hljs-built_in">empty</span>())<br>        _timer.<span class="hljs-built_in">stop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="tick"><code>tick()</code></h4><p>当Sender处于<code>SYN SENT</code>、<code>SYN ACKED</code>或是<code>FIN SENT</code>状态时，调用<code>Timer</code>检查当前是否过期。</p><p>如果已过期，则：</p><ul><li>若<code>window size</code>非<code>0</code>或<code>SYN</code>未确认收到时，执行指数退避。</li><li>若重传次数小于<code>TCP</code>内建的限制次数时，立即重传并<strong>重启</strong><code>Timer</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_status == SYN_SENT <span class="hljs-keyword">or</span> _status == SYN_ACKED <span class="hljs-keyword">or</span> _status == FIN_SENT)<br>        <span class="hljs-keyword">if</span> (_timer.<span class="hljs-built_in">check_expired</span>(ms_since_last_tick)) &#123;<br>            <span class="hljs-keyword">if</span> (_window_size || _status == SYN_SENT)<br>                _timer.<span class="hljs-built_in">exponential_backoff</span>();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">consecutive_retransmissions</span>() &lt;= TCPConfig::MAX_RETX_ATTEMPTS) &#123;<br>                _segments_out.<span class="hljs-built_in">push</span>(_segments_cache.<span class="hljs-built_in">front</span>());<br>                _timer.<span class="hljs-built_in">restart</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                _status = ERROR;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="consecutive-retransmissions"><code>consecutive_retransmissions()</code></h4><p>返回<code>Timer</code>中记录的重传次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">TCPSender::consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <br>  <span class="hljs-keyword">return</span> _timer.<span class="hljs-built_in">consecutive_retransmissions_times</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/785ad61c.html">https://zone.ivan-zhang.com.cn/p/785ad61c.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144计算机网络Lab2: The TCP Receiver</title>
    <link href="/p/b9f66227.html"/>
    <url>/p/b9f66227.html</url>
    
    <content type="html"><![CDATA[<center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/15/652c095ff0876.png" alt="CS144TCPSocket" style="zoom:25%;" /><br>  <font color="DimGray" size="3">The arrangement of modules and dataflow in TCP implementation.</font></center>`Lab2`要求实现一个`TCPReceiver`，包含以下几个功能：<ul><li>接收<code>TCPSegment</code>；</li><li>调用字节流重组器；</li><li>向发送方发送相应确认信号；</li><li>流量控制。</li></ul><p>这次的实验主要分为<code>Translating between 64-bit indexes and 32-bit seqnos</code>和<code>Implementing the TCP receiver</code>两个部分。前者是学习实现<code>TCPSegment</code>中的索引方式；后者是实现<code>TCPReceiver</code>的主要功能。</p><h2 id="A-Translating-between-64-bit-indexes-and-32-bit-seqnos">A. Translating between 64-bit indexes and 32-bit seqnos</h2><p>这一部分需要实现<code>TCP</code>中表示索引的方式，在<a href="https://zone.ivan-zhang.com.cn/posts/5858.html"><code>Lab1</code></a>中我们实现了<code>StreamReassembler</code>，其中使用的<code>index</code>就是一个<code>64-bit</code> 并从<code>0</code>开始计数的<code>stream index</code>。然而<code>TCP</code>的首部空间寸土寸金，直接占用<code>64-bit</code>为免也太奢侈了，所以在实践中，通常使用<code>32-bit</code>的<code>sequence number</code>或<code>seqno</code>表示。这样一个用低位数据来表示高位数据的方法自然而然地又了了以下几个挑战：</p><ul><li>当<code>32-bit</code>空间用完<code>(到达2^32-1)</code>后，需要对其进行重置，从<code>0</code>开始重新计数，即<code>(mod 2^32)</code>；</li><li>为了避免以前连接中旧数据包造成混淆，在<code>TPC</code>连接建立阶段需要随机确定一个<code>32-bit</code>的初始值即<code>ISN(Initial Sequence Number)</code>，尽量保证序列号<strong>不可被预判</strong>或<strong>与之前重复</strong>；</li><li>为了保证开始信号、字节数据和数据结束信号可靠接收，在<code>TCP</code>中，<code>SYN(beginning of stream)</code>和<code>FIN(end of stream)</code>分别占用两个序列号，<code>SYN</code>占用第一个序列号也就是<code>ISN</code>，数据字节后续的序列号如<code>ISN+1 (mod 2^32)</code>、<code>ISN+2 (mod 2^32)</code>等等，最后<code>FIN</code>占用流后的一个序列号。</li></ul><p>在TCP中，索引有以下三种：</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/21/6532a9e34f0ef.png" alt="TCPIndex-Example" style="zoom:40%;" />  <br>  <font color="DimGray" size="3">An Example of Bitstream "cat".</font>  <br>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/21/6532aa42d64cf.png" alt="TCPIndex" style="zoom:40%;" />  <br>  <font color="DimGray" size="3">Three Different Types of Indexing Involved in TCP.</font></center><p>可以看到，absloute seqno与<code>stream index</code>之间非常好转换，而<code>seqno</code>与<code>absolute seqno</code>由于空间大小不一样，转换需要进行额外的操作。这一部分需要做的就是，根据头文件<code>wrapping integers.hh</code>完成<code>wrapping integers.cc</code>中的两个转换函数。</p><h3 id="Convert-absolute-seqno-→-seqno">Convert absolute seqno → seqno.</h3><p>对于<code>64-bit</code>的<code>absolute seqno</code>，先对它取模，确保在<code>32-bit</code>范围内，之后加上<code>ISN</code>再取模，得到<code>32-bit</code>的<code>seqno</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(n, isn);</span><br>        <span class="hljs-type">uint64_t</span> mod = <span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">32</span>;<br>        <span class="hljs-function">WrappingInt32 <span class="hljs-title">seqno</span> <span class="hljs-params">((n % mod + isn.raw_value()) % mod)</span></span>;<br>        <span class="hljs-keyword">return</span> seqno;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Convert-seqno-→-absolute-seqno">Convert seqno → absolute seqno.</h3><p>对于<code>32-bit</code>的<code>seqno</code>，需要找到距离checkpoint最近的absolute seqno，</p><ul><li>先确定<code>seqno</code>与ISN之间的偏移量；</li><li>在数轴上，位于<code>checkpoint</code>左侧的为<code>absolute_seqno_left</code>，右侧的为<code>absolute_seqno_right</code>，均初始化为<code>absolute_seqno_wrap</code>；</li><li>不断以<code>2^32</code>为单位增长<code>absolute_seqno_wrap</code>，直到<code>absolute_seqno_wrap &gt; checkpoint</code>，此时获取到了<code>absolute_seqno_left</code>与<code>absolute_seqno_right</code>，选取他们之中距离<code>checkpoint</code>最近的即为<code>absolute_seqno</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-type">uint64_t</span> checkpoint)</span> </span>&#123;<br>    <span class="hljs-comment">//    DUMMY_CODE(n, isn, checkpoint);</span><br>    <span class="hljs-type">uint64_t</span> mod = <span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>;<br>    <span class="hljs-type">uint64_t</span> absolute_seqno_wrap = n.<span class="hljs-built_in">raw_value</span>() - isn.<span class="hljs-built_in">raw_value</span>();<br>    <span class="hljs-type">uint64_t</span> absolute_seqno_right = absolute_seqno_wrap;<br>    <span class="hljs-type">uint64_t</span> absolute_seqno_left = absolute_seqno_wrap;<br>    <span class="hljs-keyword">while</span> (absolute_seqno_wrap &lt; checkpoint) &#123;<br>        absolute_seqno_wrap += mod;<br>        <span class="hljs-keyword">if</span> (absolute_seqno_wrap &lt; checkpoint)<br>            absolute_seqno_left = absolute_seqno_wrap;<br>        <span class="hljs-keyword">if</span> (absolute_seqno_wrap &gt; checkpoint)<br>            absolute_seqno_right = absolute_seqno_wrap;<br>    &#125;<br>    <span class="hljs-keyword">return</span> absolute_seqno_right - checkpoint &gt; checkpoint - absolute_seqno_left ? absolute_seqno_left<br>                                                                                : absolute_seqno_right;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改与改进">修改与改进</h3><p>在测试<code>test4</code>的时候遇到了问题：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span>/<span class="hljs-number">1</span> Test <span class="hljs-comment">#4: t_wrapping_ints_roundtrip ........***Failed    0.16 sec</span><br>Expected unwrap(wrap()) <span class="hljs-keyword">to</span> recover same value, <span class="hljs-keyword">and</span> <span class="hljs-keyword">it</span> didn&#x27;t!<br>  unwrap(wrap(value, isn), isn, checkpoint) did <span class="hljs-keyword">not</span> <span class="hljs-keyword">equal</span> value<br>  <span class="hljs-keyword">where</span> value = <span class="hljs-number">1383509345922390960</span>, isn = <span class="hljs-number">549282053</span>, <span class="hljs-keyword">and</span> checkpoint = <span class="hljs-number">1383509345922390960</span><br>  (Difference <span class="hljs-keyword">between</span> value <span class="hljs-keyword">and</span> checkpoint <span class="hljs-keyword">is</span> <span class="hljs-number">0.</span>)<br></code></pre></td></tr></table></figure><p>是因为没有考虑<code>absolute_seqno_wrap == checkpoint</code>的情况，于是增加了特判。除此之外为了防止<code>absolute_seqno_wrap</code>溢出增加了新的判定在<code>while() &#123;&#125;</code>中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (absolute_seqno_wrap &lt;= checkpoint) &#123;<br>        <span class="hljs-keyword">if</span> (UINT64_MAX - absolute_seqno_wrap &lt; mod || absolute_seqno_wrap == checkpoint)<br>            <span class="hljs-keyword">return</span> absolute_seqno_wrap;<br>        <span class="hljs-keyword">else</span><br>            absolute_seqno_wrap += mod;<br>        <span class="hljs-keyword">if</span> (absolute_seqno_wrap &lt; checkpoint)<br>            absolute_seqno_left = absolute_seqno_wrap;<br>        <span class="hljs-keyword">if</span> (absolute_seqno_wrap &gt; checkpoint)<br>            absolute_seqno_right = absolute_seqno_wrap;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后又跑了一下，在<code>test4</code>怎么也不出结果，以为有<code>死循环</code>，但是查了半天逻辑并无错误，看了一眼测试，，，跑<code>1000000</code>轮，原来只是<code>单纯的慢</code>罢了。</p><p><strong>那么如何改进，分析一下：</strong></p><p>前面的方案是通过循环累加确定<code>checkpoint</code>附近的<code>absolute seqno</code>，这个流程可以通过取模+除法操作替代，这就意味着计算未接近<code>checkpoint</code>的<code>32-bit</code>区间是毫无意义的，我们只需要考虑<code>checkpoint</code>所在的当前区间以及其前后区间即可。</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/24/653789844035c.png" alt="区间" style="zoom:17%;" />  <br>  <font color="DimGray" size="3">当前以及其前后32bit区间.</font></center><p>那么这样的话就有以下几种情况：</p><ul><li>在<code>checkpoint</code>与当前区间的<code>absolute seqno</code>重合时，<code>checkpoint</code>的位置就是<code>absolute seqno</code>；</li><li>当<code>checkpoint</code>的位置在当前区间中的<code>absolute seqno</code>的右侧时，会存在两个情况：<ul><li><code>checkpoint</code>在最后一个区间中，只有当前区间才有<code>absolute seqno</code>；</li><li><code>checkpoint</code>不在最后一个区间中，只有在当前区间和其后区间可能存在<code>absolute seqno</code>；</li></ul></li><li>当<code>checkpoint</code>的位置在当前区间中的<code>absolute seqno</code>的左侧时，也会存在两个情况：<ul><li><code>checkpoint</code>在第一个区间中，只有当前区间才有<code>absolute seqno</code>；</li><li><code>checkpoint</code>不在第一个区间中，只有在当前区间和前一个区间可能存在<code>absolute seqno</code>。</li></ul></li></ul><p>最后通过了测试的代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-type">uint64_t</span> checkpoint)</span> </span>&#123;<br>    <span class="hljs-comment">//    DUMMY_CODE(n, isn, checkpoint);</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> mod = <span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> checkpoint_32 = checkpoint % mod;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> absolute_n = n.<span class="hljs-built_in">raw_value</span>() - isn.<span class="hljs-built_in">raw_value</span>();<br>    <span class="hljs-keyword">if</span> (UINT64_MAX - checkpoint &lt; mod || absolute_n == checkpoint_32)<br>        <span class="hljs-keyword">return</span> (checkpoint / mod) * mod + absolute_n;<br>    <span class="hljs-keyword">if</span> (checkpoint_32 &gt; absolute_n)<br>        <span class="hljs-keyword">return</span> checkpoint_32 - absolute_n &gt; mod - checkpoint_32 + absolute_n<br>                   ? ((checkpoint / mod) + <span class="hljs-number">1</span>) * mod + absolute_n<br>                   : (checkpoint / mod) * mod + absolute_n;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (checkpoint &lt; mod)<br>            <span class="hljs-keyword">return</span> absolute_n;<br>        <span class="hljs-keyword">return</span> absolute_n - checkpoint_32 &gt; mod + checkpoint_32 - absolute_n<br>                   ? ((checkpoint / mod) - <span class="hljs-number">1</span>) * mod + absolute_n<br>                   : (checkpoint / mod) * mod + absolute_n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Implementing-the-TCP-receiver">B. Implementing the TCP receiver</h2><p><code>TCPReceiver</code>在运行过程中会收到这样格式的<code>TCPSegment</code>：</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/23/6535f5f09de27.png" alt="TCPSegment" style="zoom:75%;" />  <br>  <font color="DimGray" size="3">TCPSegment.</font></center><p>现在，需要根据<code>tcp_receiver.hh</code>来实现一下<code>TCPReceiver</code>：</p><p>首先需要增加三个变量：</p><ul><li><code>_isn</code>：储存存入第一次成功建立连接时的<code>seqno</code>；</li><li><code>_syn</code> ：判断连接是否建立；</li><li>_fin：判断连接是否终止。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPReceiver</span> &#123;<br>    <span class="hljs-comment">//! Our data structure for re-assembling bytes.</span><br>    StreamReassembler _reassembler;<br><br>    <span class="hljs-comment">//! The maximum number of bytes we&#x27;ll store.</span><br>    <span class="hljs-type">size_t</span> _capacity;<br><br>    WrappingInt32 _isn&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">bool</span> _syn = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> _fin = <span class="hljs-literal">false</span>;<br>  <br>  <span class="hljs-comment">/*codes*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>segment_received</code>的实现思路是：</p><ul><li>首先判断<code>seg.header().syn</code>是否为<code>true</code>且当前链接未建立时，设置<code>_isn</code>为<code>seqno</code>并建立连接，否则当链接不存在时，直接返回。</li><li>之后向<code>reassembler</code>中推送收到的<code>TCPSegment</code>中的数据；</li><li>最后当且仅当<code>seg.header().fin</code>为<code>true</code>时，将<code>_fin</code>记录为终止状态。</li></ul><p><code>ackno</code>的实现思路是：</p><ul><li>首先判断链接是否建立，如果为建立则直接返回<code>nullopt</code>；</li><li>如果建立了则返回下一个需要进行整合的<code>seqno</code>，从<code>absolute seqno</code>的角度来看即为 <code>_reassembler.stream_out().bytes_written() + 1</code>，同时需要注意<code>syn</code>与<code>fin</code>也会分别占用了一个seqno，</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPReceiver::segment_received</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPSegment &amp;seg)</span> </span>&#123;<br>    <span class="hljs-comment">//    DUMMY_CODE(seg);</span><br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().syn &amp;&amp; !_syn) &#123;<br>        _isn = seg.<span class="hljs-built_in">header</span>().seqno;<br>        _syn = seg.<span class="hljs-built_in">header</span>().syn;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!_syn) <span class="hljs-keyword">return</span>;<br>    _reassembler.<span class="hljs-built_in">push_substring</span>(seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">copy</span>(),<br>                                <span class="hljs-built_in">unwrap</span>(seg.<span class="hljs-built_in">header</span>().seqno, _isn, _reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>() + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span> +<br>                                    seg.<span class="hljs-built_in">header</span>().syn,<br>                                seg.<span class="hljs-built_in">header</span>().fin);<br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().fin) _fin = seg.<span class="hljs-built_in">header</span>().fin;<br>&#125;<br><br><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _syn ? optional&lt;WrappingInt32&gt;&#123;<span class="hljs-built_in">wrap</span>(_reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>() + _syn + (_fin &amp;&amp; _reassembler.<span class="hljs-built_in">empty</span>()), _isn)&#125;<br>                : <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPReceiver::window_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _capacity - _reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">buffer_size</span>(); &#125;<br></code></pre></td></tr></table></figure><p>在写<code>segment_received</code>的时候，在<code>recv_specal</code>这个测试中卡了好久，这里面设计了很多<code>syn</code>、<code>fin</code>与数据结合的<code>Segment</code>，需要特别注意下。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/b9f66227.html">https://zone.ivan-zhang.com.cn/p/b9f66227.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144计算机网络Lab1: Stitching Substrings into a Byte Stream</title>
    <link href="/p/8eb2211f.html"/>
    <url>/p/8eb2211f.html</url>
    
    <content type="html"><![CDATA[<center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/15/652c095ff0876.png" alt="CS144TCPSocket" style="zoom:25%;" /><br>  <font color="DimGray" size="3">The arrangement of modules and dataflow in TCP implementation.</font></center>`Lab1`要求实现一个`StreamReassembler`，也就是接收端的`滑动窗口`，包含以下几个功能：<ul><li>将零散的字节流片段拼接成顺序正确的字节流；</li><li>忽略重复传输的数据包；</li><li>拒绝过早传输的数据包；</li><li>将排序好的字节流传递给上层的<code>ByteStream</code>。</li></ul><h2 id="A-Putting-substrings-in-sequence">A. Putting substrings in sequence</h2><p>在pdf中，作者给出了一个<code>StreamReassembler</code>的简单示意图，不过比较抽象</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/16/652ceff38d891.png" alt="StreamReassembler" style="zoom:65%;" /><br>  <font color="DimGray" size="3">StreamReassembler.</font></center><h3 id="首次尝试">首次尝试</h3><p>具体来说，对于外部输入随机排列的<code>substring</code>，使用滑动窗口处理陆续到达的<code>substring</code>并将它们全部储存在<code>buffer_string</code>中，其中滑动窗口是由<code>_reassembled_pt</code>和<code>_end_pt</code>两个指针组成，并保证<code>_end_pt - _reassembled_pt &lt;= _capacity</code>；同时维护一个<code>buffer_check</code>用来储存<code>buffer_string</code>中每个字节的占用情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamReassembler</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Your code here -- add private members as necessary.</span><br>    std::string buffer_string;<br>    std::string buffer_check;<br>    <span class="hljs-type">size_t</span> _reassembled_pt;<br>    <span class="hljs-type">size_t</span> _end_pt;<br>    <br>    <span class="hljs-comment">/*code*/</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">StreamReassembler::<span class="hljs-built_in">StreamReassembler</span>(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity) : <span class="hljs-built_in">buffer_string</span>(<span class="hljs-string">&quot;&quot;</span>), <span class="hljs-built_in">buffer_check</span>(<span class="hljs-string">&quot;&quot;</span>), _reassembled_pt(<span class="hljs-number">0</span>), _end_pt(<span class="hljs-number">-1</span>), _output(capacity), _capacity(capacity) &#123;&#125;<br></code></pre></td></tr></table></figure><p>对于<code>push_substring()</code>，<code>workflow</code>如下：</p><center>  <img src="http://lsky.ivan-zhang.com.cn/i/2023/10/16/652d1588dde32.jpeg" alt="StreamReassembler" style="zoom:30%;" /><br>  <font color="DimGray" size="3">StreamReassembler.</font></center><ul><li>计算插入<code>data</code>后buffer_string的长度：<code>extended_length = index + data.length()</code>；</li><li>检查<code>extended_length</code>是否超出<code>capacity</code>，若超出则直接<code>return</code>；</li><li>检查<code>eof</code>是否为<code>true</code>，将<code>_end_pt</code>设置成<code>extended_length</code>；</li><li>将<code>buffer_string</code>和<code>buffer_check</code>的长度扩展到<code>extended_length</code>，并写入<code>data</code>同时将对应位置的<code>check</code>置为<code>1</code>；</li><li>如果<code>_reassembled_pt</code>位置上的比特非空，就写入到<code>ByteStream</code>，并右移<code>_reassembled_pt</code>直到遇到空位或<code>_reassembled_pt == _end_pt</code>；</li><li>当<code>_reassembled_pt == _end_pt</code>时，结束<code>ByteStream</code>输入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(data, index, eof);</span><br><br>    <span class="hljs-type">size_t</span> extended_length = index + data.<span class="hljs-built_in">length</span>();<br><br>    <span class="hljs-keyword">if</span> (extended_length &gt; _capacity)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (eof)<br>        _end_pt = extended_length;<br><br>    buffer_string.<span class="hljs-built_in">resize</span>(extended_length),<br>    buffer_check.<span class="hljs-built_in">resize</span>(extended_length),<br>    buffer_string.<span class="hljs-built_in">replace</span>(index,data.<span class="hljs-built_in">length</span>(),data);<br>    buffer_check.<span class="hljs-built_in">replace</span>(index,data.<span class="hljs-built_in">length</span>(),data.<span class="hljs-built_in">length</span>(),<span class="hljs-string">&#x27;1&#x27;</span>);<br><br>    <span class="hljs-keyword">while</span>(buffer_check[_reassembled_pt] &amp;&amp; _output.<span class="hljs-built_in">remaining_capacity</span>())&#123;<br>        _output.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">to_string</span>(buffer_string[_reassembled_pt]));<br>        _reassembled_pt++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_reassembled_pt == _end_pt)<br>        _output.<span class="hljs-built_in">end_input</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>unassembled_bytes()</code>函数，我们需要查看滑动窗口里未被连续填充的区间中填充byte的数量，也就是当<code>_reassembled_pt</code>处为空时，在其之后的<code>substring</code>数量，这里直接遍历一边就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">StreamReassembler::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> bytes_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = _reassembled_pt; i != buffer_check.<span class="hljs-built_in">length</span>(); i++)<br>        <span class="hljs-keyword">if</span>(buffer_check[i] == <span class="hljs-string">&#x27;1&#x27;</span>) bytes_cnt++;<br>    <span class="hljs-keyword">return</span> bytes_cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，判断<code>StreamReassembler</code>是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StreamReassembler::empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> !<span class="hljs-built_in">unassembled_bytes</span>(); &#125;<br></code></pre></td></tr></table></figure><p>然而，这个方案不能通过测试。</p><h3 id="进一步改进">进一步改进</h3><p>经过复盘发现了一些问题：</p><ol><li>当<code>extended_length</code>超过<code>_capacity</code>时就直接全部抛弃了，没有考虑部分输入的情况，正确的逻辑应该是仅抛弃无法写入的<code>unacceptable</code>字节；</li><li><code>eof</code>也没有考虑<code>unacceptable</code>字节的问题，需要对本次<code>data</code>是否能完整写入进行判定；</li><li>在写入<code>ByteStream</code>时，逐个进行的，并且进行了类型转换。</li><li>除此之外，在一开始进行分析的时候对<code>_reassembled_pt</code>和<code>_end_pt</code>的说明是<code>_end_pt - _reassembled_pt &lt;= _capacity</code>，忽略了<code>_end_pt</code>与<code>eof</code>的联系。</li></ol><p>经过修改新<code>workflow</code>如下：</p><ul><li>计算插入<code>data</code>后<code>buffer_string</code>的长度：<code>extended_length = index + data.length()</code>  ----&gt;<strong>插入长度</strong>；</li><li>计算符合<code>_capacity</code>要求理论最大长度：<code>max_expended_length = _reassembled_pt + _capacity</code>  ----&gt;<strong>最大长度</strong>；</li><li>检查<code>index</code>是否超出<code>capacity</code>，若超出则直接<code>return</code>；</li><li>检查<code>eof</code>是否为<code>true</code>，且如果本次的<code>data</code>能完全插入则令<code>_end_pt = expended_length</code>；</li><li>调整<code>buffer</code>并插入<code>data</code><ul><li>如果<strong>插入长度</strong>大于当前<code>buffer_string</code>的长度，则将<code>buffer_string</code>和<code>buffer_check</code>扩展到<strong>插入长度</strong>；</li><li>写入<code>data</code>同时将对应位置的<code>check</code>置为<code>1</code>；</li><li>如果插入后当前<code>buffer_string</code>的长度大于<strong>最大长度</strong>，则将<code>buffer_string</code>和<code>buffer_check</code>缩短到<strong>最大长度</strong>，抛弃掉<code>unacceptable</code>字节。</li></ul></li><li>如果<code>_reassembled_pt</code>位置上的比特非空，就写入到<code>ByteStream</code>，并右移<code>_reassembled_pt</code>直到遇到空位或<code>_output</code>已满；</li><li>当<code>_reassembled_pt == _end_pt</code>时，结束<code>ByteStream</code>输入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(data, index, eof);</span><br>    <span class="hljs-type">size_t</span> expended_length = index + data.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">size_t</span> max_expended_length = _reassembled_pt + _capacity;<br><br>    <span class="hljs-keyword">if</span> (index &gt; max_expended_length)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (eof &amp;&amp; expended_length &lt;= max_expended_length)<br>        _end_pt = expended_length;<br><br>    <span class="hljs-keyword">if</span> (expended_length &gt; buffer_string.<span class="hljs-built_in">length</span>()) &#123;<br>        buffer_string.<span class="hljs-built_in">resize</span>(expended_length);<br>        buffer_check.<span class="hljs-built_in">resize</span>(expended_length);<br>    &#125;<br><br>        buffer_string.<span class="hljs-built_in">replace</span>(index, data.<span class="hljs-built_in">length</span>(), data);<br>        buffer_check.<span class="hljs-built_in">replace</span>(index, data.<span class="hljs-built_in">length</span>(), data.<span class="hljs-built_in">length</span>(), <span class="hljs-string">&#x27;1&#x27;</span>);<br><br>    <span class="hljs-keyword">if</span> (buffer_string.<span class="hljs-built_in">length</span>() &gt; max_expended_length)&#123;<br>        buffer_string.<span class="hljs-built_in">resize</span>(max_expended_length);<br>        buffer_check.<span class="hljs-built_in">resize</span>(max_expended_length);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (buffer_check[_reassembled_pt] &amp;&amp; _output.<span class="hljs-built_in">remaining_capacity</span>())&#123;<br>        <span class="hljs-type">size_t</span> write_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(buffer_check[_reassembled_pt + write_len] &amp;&amp; _output.<span class="hljs-built_in">remaining_capacity</span>() - write_len) write_len++;<br>        _output.<span class="hljs-built_in">write</span>(buffer_string.<span class="hljs-built_in">substr</span>(_reassembled_pt,write_len));<br>        _reassembled_pt += write_len;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_reassembled_pt == _end_pt)<br>        _output.<span class="hljs-built_in">end_input</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过了<code>test</code>。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/8eb2211f.html">https://zone.ivan-zhang.com.cn/p/8eb2211f.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144计算机网络Lab0: Networking Warmup</title>
    <link href="/p/30fba476.html"/>
    <url>/p/30fba476.html</url>
    
    <content type="html"><![CDATA[<p>热身分为三个部分，第一部分要求用<code>telnet</code>工具来发送一些简单的http请求，第二部分是写一个简单的<code>webget</code>应用模拟使用<code>telnet</code>是的操作，第三部分是完善一个<code>ByteStream</code>来实现更底层的<code>socket</code>写入读取等操作</p><h2 id="第一部分-Networking-by-hand">第一部分 - Networking by hand</h2><h3 id="A-Fetch-a-Web-page">A. Fetch a Web page</h3><p>通过在浏览器中访问<code>http://cs144.keithw.org/hello</code>，我们得到一条信息<code>Hello, CS144!</code>，现在让我们用<code>telnet</code>来实现这个过程：</p><ul><li><p>首先需要通过<code>telnet</code>与<code>cs144.keithw.org</code>建立<code>reliable byte stream</code>，并告诉对方我们我们接下来的请求将使用<code>http</code>协议：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ telnet cs144.keithw.org http<br>Trying 198.18.0.30...<br>Connected to cs144.keithw.org.<br>Escape character is &#x27;^]&#x27;.<br></code></pre></td></tr></table></figure></li></ul><p>​现在我们就可以发送请求了</p><ul><li><p>继续发送</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/hello</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>cs144.keithw.org<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br></code></pre></td></tr></table></figure><p>值得注意的是，服务器需要在超时之前接收到请求，我刚开始的时候一行一行地输入，由于打字速度感人，就会由于超时而收到<code>Connection closed by foreign host.</code>。除此之外，再写好请求后需要多按两次回车告诉<code>telnet</code>发送该请求。</p></li><li><p>最后我们得到了理想的返回响应</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Sun, 15 Oct 2023 04:38:14 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Thu, 13 Dec 2018 15:45:29 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;e-57ce93446cb64&quot;<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>14<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><br><span class="language-pgsql">Hello, CS144!</span><br><span class="language-pgsql"><span class="hljs-keyword">Connection</span> closed <span class="hljs-keyword">by</span> <span class="hljs-keyword">foreign</span> host.</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="Assignment">Assignment</h4><p>最后有一个任务，要求从<code>http://cs144.keithw.org/lab0/sunetid</code>获取<code>secret code</code>，这个就非常的简单了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ telnet cs144.keithw.org http<br>Trying 198.18.0.30...<br>Connected to cs144.keithw.org.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>GET /lab0/0001 HTTP/1.1<br>Host: cs144.keithw.org<br>Connection: close<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Sun, 15 Oct 2023 04:47:40 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache<br><span class="hljs-attribute">X-You-Said-Your-SunetID-Was</span><span class="hljs-punctuation">: </span>0001<br><span class="hljs-attribute">X-Your-Code-Is</span><span class="hljs-punctuation">: </span>427826<br><span class="hljs-attribute">Content-length</span><span class="hljs-punctuation">: </span>108<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><br><span class="language-applescript">Hello! You told us <span class="hljs-keyword">that</span> your SUNet ID was <span class="hljs-string">&quot;0001&quot;</span>. Please see <span class="hljs-keyword">the</span> HTTP headers (<span class="hljs-keyword">above</span>) <span class="hljs-keyword">for</span> your secret code.</span><br><span class="language-applescript">Connection closed <span class="hljs-keyword">by</span> foreign host.</span><br></code></pre></td></tr></table></figure><h3 id="B-Send-yourself-an-email"><s>B.Send yourself an email</s></h3><h3 id="C-Listening-and-connecting">C. Listening and connecting</h3><p>在上面我们使用<code>telnet</code>向服务器发送请求，现在我们将成为一个简单的服务器，接受外部的信息</p><ul><li><p>使用<code>netcat</code>监听9090端口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ netcat -v -l -p 9090<br>Listening on 0.0.0.0 9090<br></code></pre></td></tr></table></figure></li><li><p>在另一个终端中运行<code>telnet</code>，连接到本地的<code>9090</code>端口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ telnet localhost 9090<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br></code></pre></td></tr></table></figure></li><li><p>现在，我们可以在两个终端之间互相发送信息了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ netcat -v -l -p 9090<br>Listening on 0.0.0.0 9090<br>Connection received on localhost 60162<br>hello, this is Ivan, <span class="hljs-built_in">bye</span>~<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ telnet localhost 9090<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>hello, this is Ivan, <span class="hljs-built_in">bye</span>~<br></code></pre></td></tr></table></figure></li></ul><h2 id="第二部分-Writing-a-network-program-using-an-OS-stream-socket">第二部分 - Writing a network program using an OS stream socket</h2><p>这一部分需要通过系统内建的<code>stream socket</code>写一个简单的<code>webget</code>来实现之前<code>telnet</code>,具体来说，需要完善<code>apps/webget.cc</code>中的<code>get_URL</code>函数。我们可以参考<code>doctests/address_example_1.cc</code>和<code>doctests/socket_example_2.cc</code>，实际上就是初始化一个<code>TCPSocket</code>并通过目标<code>Address</code>建立连接，之后向服务求发送之前类似的请求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Your code here.</span><br><br>TCPSocket con;<br>con.<span class="hljs-built_in">connect</span>(<span class="hljs-built_in">Address</span>(host, <span class="hljs-string">&quot;http&quot;</span>));<br>con.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\n&quot;</span>);<br>con.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Host: &quot;</span> + host + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>con.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Connection: close\r\n&quot;</span>);<br>con.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><br><span class="hljs-keyword">while</span>(!con.<span class="hljs-built_in">eof</span>())&#123;<br>    cout &lt;&lt; con.<span class="hljs-built_in">read</span>();<br>&#125;<br>con.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><p>在<code>Connection: close\r\n</code>之后，仍然需要写入一个<code>回车</code>告诉<code>socket</code>可以发送了，不然会一直等待直到超时。</p><p>测试一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  build git:(main) ✗ make check_webget<br>[100%] Testing webget...<br>Test project /root/CS144Learn/build<br>    Start 31: t_webget<br>1/1 Test <span class="hljs-comment">#31: t_webget .........................   Passed    1.30 sec</span><br><br>100% tests passed, 0 tests failed out of 1<br><br>Total Test time (real) =   1.32 sec<br>[100%] Built target check_webget<br></code></pre></td></tr></table></figure><h2 id="第三部分-An-in-memory-reliable-byte-stream">第三部分 - An in-memory reliable byte stream</h2><p>这一部分要求我们根据<code>pdf</code>中<code>writer</code>和<code>reader</code>的接口来完善<code>libsponge/byte stream.hh</code>和<code>libsponge/byte stream.cc</code>，并能处理比<code>buffer</code>容量要长的多的字节流。</p><p><code>byte stream.hh</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteStream</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Your code here -- add private members as necessary.</span><br>    std::string string_buffer;<br>    <span class="hljs-type">size_t</span> _buffer_size;<br>    <span class="hljs-type">size_t</span> _bytes_written;<br>    <span class="hljs-type">size_t</span> _bytes_read;<br><span class="hljs-comment">//    bool _buffer_empty = false;</span><br>    <span class="hljs-type">bool</span> _is_input_ended = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">/*code*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>byte stream.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++">ByteStream::<span class="hljs-built_in">ByteStream</span>(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity) : <span class="hljs-built_in">string_buffer</span>(<span class="hljs-string">&quot;&quot;</span>), _buffer_size(capacity), _bytes_written(<span class="hljs-number">0</span>), _bytes_read(<span class="hljs-number">0</span>) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::write</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(data);</span><br>    <span class="hljs-type">size_t</span> write_cnt = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">remaining_capacity</span>(), data.<span class="hljs-built_in">length</span>());<br>    string_buffer += std::<span class="hljs-built_in">move</span>(data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,write_cnt));<br>    _bytes_written += write_cnt;<br><br>    <span class="hljs-keyword">return</span> write_cnt;<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be copied from the output side of the buffer</span><br><span class="hljs-function">string <span class="hljs-title">ByteStream::peek_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(len);</span><br>    <span class="hljs-keyword">return</span> string_buffer.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,len);<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be removed from the output side of the buffer</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ByteStream::pop_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br><span class="hljs-comment">//    DUMMY_CODE(len);</span><br>    string_buffer.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>,len);<br>    _bytes_read+=len;<br>&#125;<br><br><span class="hljs-comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span><br><span class="hljs-comment">//! \param[in] len bytes will be popped and returned</span><br><span class="hljs-comment">//! \returns a string</span><br><span class="hljs-function">std::string <span class="hljs-title">ByteStream::read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">//    DUMMY_CODE(len);</span><br>    std::string copied_str = <span class="hljs-built_in">peek_output</span>(len);<br>    <span class="hljs-built_in">pop_output</span>(len);<br><br>    <span class="hljs-keyword">return</span> copied_str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ByteStream::end_input</span><span class="hljs-params">()</span> </span>&#123; _is_input_ended = <span class="hljs-literal">true</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::input_ended</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_input_ended; &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::buffer_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> string_buffer.<span class="hljs-built_in">length</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> string_buffer.<span class="hljs-built_in">empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::eof</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_input_ended &amp;&amp; <span class="hljs-built_in">buffer_empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::bytes_written</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _bytes_written; &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::bytes_read</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _bytes_read; &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _buffer_size - <span class="hljs-built_in">buffer_size</span>(); &#125;<br></code></pre></td></tr></table></figure><p>在一开始做这个实验的时候，完全不知道需要干什么，之前学的C++还有面向对象的知识都忘了不少。实际上只需要按照每个模块的功能一步步写+<code>debug</code>就好了。</p><p>在测试的时候经常会出现<code>The ByteStream should have had bytes_written equal to 0 but instead it was 1</code>这样的错误，后面发现是我在定义<code>string_buffer</code>的时候把它初始化为了<code>&quot; &quot;</code>，而正常应该是为<code>空</code>。</p><p>本文链接:  <a href="https://zone.ivan-zhang.com.cn/p/30fba476.html">https://zone.ivan-zhang.com.cn/p/30fba476.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
